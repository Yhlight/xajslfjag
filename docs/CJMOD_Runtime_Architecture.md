# CJMOD运行时架构详解

## 问题与解决方案

### 核心问题
CJMOD需要在编译时扩展CHTL JS语法，但C++扩展是编译后的二进制代码，如何在编译时获取并处理代码片段？

### 解决方案：混合编译模型

CJMOD采用"**语法定义与代码生成分离**"的架构：

1. **语法定义（编译时静态）**：使用JSON文件定义语法模式
2. **代码生成（运行时动态）**：匹配后调用C++扩展生成代码

## 工作流程

### 1. 扩展加载阶段

```
┌─────────────────┐
│   .cjmod文件    │
└────────┬────────┘
         │ 解压
         ▼
┌─────────────────┐     ┌──────────────────┐
│ manifest.json   │     │ extension.so/dll │
│ syntax/*.json   │     │  (C++扩展库)     │
└────────┬────────┘     └─────────┬────────┘
         │                        │
         ▼                        ▼
    解析语法定义              动态加载但不执行
         │                        │
         ▼                        ▼
┌──────────────────────────────────────────┐
│          CJMOD Runtime Manager           │
│  ┌──────────────┐   ┌─────────────────┐ │
│  │ 语法模式列表  │   │  扩展实例映射   │ │
│  └──────────────┘   └─────────────────┘ │
└──────────────────────────────────────────┘
```

### 2. 编译阶段

```
CHTL JS源代码
     │
     ▼
┌─────────────────┐
│  统一扫描器     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ CHTL JS Lexer   │◄─── 读取语法模式列表
└────────┬────────┘     (从JSON定义)
         │
         ▼
┌─────────────────┐
│ 语法模式匹配    │
│ (正则表达式)    │
└────────┬────────┘
         │
         ▼ 匹配成功
┌─────────────────┐
│ 标记代码片段    │
│ (记录位置信息)  │
└─────────────────┘
```

### 3. 代码生成阶段

```
标记的代码片段
     │
     ▼
┌─────────────────┐
│ 提取匹配信息    │
│ - 语法名称      │
│ - 匹配文本      │
│ - 捕获组        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 调用C++扩展     │
│ extension->     │
│   process(...)  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 生成JavaScript  │
│     代码        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 替换原始片段    │
└─────────────────┘
```

## 实现细节

### 语法定义文件格式

```json
{
    "name": "animate",
    "pattern": "animate\\s*\\{([^{}]*)\\}",
    "captureGroups": ["body"],
    "processor": "processAnimate",
    "options": {
        "multiline": true,
        "priority": 100
    }
}
```

### C++扩展接口

```cpp
class CJMODExtension {
public:
    // 编译器调用此方法处理匹配的片段
    virtual ProcessResult process(
        const std::string& syntaxName,      // 匹配的语法名
        const std::string& matchedText,     // 完整匹配文本
        const std::map<std::string, std::string>& captures  // 捕获组
    ) = 0;
};
```

### 时序图

```
CHTL JS编译器          CJMOD Runtime         C++扩展
     │                      │                   │
     │   加载.cjmod文件     │                   │
     ├─────────────────────>│                   │
     │                      │   初始化扩展      │
     │                      ├──────────────────>│
     │                      │<──────────────────┤
     │   获取语法模式       │                   │
     │<─────────────────────┤                   │
     │                      │                   │
     │   [编译源代码]       │                   │
     │                      │                   │
     │  处理匹配片段        │                   │
     ├─────────────────────>│                   │
     │                      │   调用process()   │
     │                      ├──────────────────>│
     │                      │                   │ [生成JS代码]
     │                      │<──────────────────┤
     │   返回生成的代码     │                   │
     │<─────────────────────┤                   │
     │                      │                   │
     │  [继续编译]         │                   │
```

## 优势

1. **编译时效率**：语法匹配使用静态JSON定义，无需执行C++代码
2. **运行时灵活性**：代码生成可以使用C++的全部功能
3. **安全性**：C++代码仅在需要时执行，降低安全风险
4. **可扩展性**：新语法只需添加JSON定义和对应的处理函数
5. **调试友好**：可以单独测试语法匹配和代码生成

## 示例：animate扩展的工作流程

1. **加载时**：
   - 读取`animate.json`语法定义
   - 加载`animate_extension.so`但不执行

2. **编译时**：
   - 扫描器发现`animate { ... }`
   - 正则匹配成功，提取body内容
   - 标记此片段需要扩展处理

3. **生成时**：
   - 调用`AnimateExtension::process("animate", matchedText, captures)`
   - 扩展解析动画定义，生成Web Animations API调用
   - 返回生成的JavaScript代码

4. **输出**：
   - 原始的`animate { ... }`被替换为生成的JS代码

## 总结

CJMOD通过分离语法定义（静态）和代码生成（动态），成功解决了在编译时扩展语法的问题。这种架构既保证了编译效率，又提供了强大的扩展能力。
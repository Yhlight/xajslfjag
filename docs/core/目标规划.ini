全程使用中文模式，阅读CHTL语法文档，基于CHTL语法文档，创建下述架构，
使用编程语言，C++ 17，全程听我指示开发  

我们不建议各个编译器共用文件，而是每一个编译器具有一套文件  
我们要求每一次都是完整实现，每一次任务完成之后项目都能够直接编译成功  

┌─────────────────────────────────────────────────────────────────┐
│                         CHTL源代码                               │
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    CHTLUnifiedScanner                           │
│                   (精准代码切割器)                               │
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
        ┌──────────────┬──────────────┬──────────────┬────────────┐
        │   CHTL片段   │ CHTL JS片段  │   CSS片段    │   JS片段   │
        └──────┬───────┴──────┬───────┴──────┬───────┴──────┬─────┘
               │              │              │              │
               ▼              ▼              ▼              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    CompilerDispatcher                           │
│                   (编译器调度器)                                 │
└──────┬──────────────┬──────────────┬──────────────┬────────────┘
       │              │              │              │
       ▼              ▼              ▼              ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│    CHTL     │ │   CHTL JS   │ │     CSS     │ │JavaScript   │
│  Compiler   │ │  Compiler   │ │  Compiler   │ │  Compiler   │
│  (手写)     │ │  (手写)     │ │  (ANTLR)    │ │  (ANTLR)    │
└─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘
       │              │              │              │
       └──────────────┴──────────────┴──────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      编译结果合并                                │
│                     (HTML输出)                                   │
└─────────────────────────────────────────────────────────────────┘

编译器对应关系如下  
局部style  ->  CHTL编译器  
全局style  ->  CSS编译器  
script  ->  由CHTL，CHTL JS，JS编译器共同管理  

注意！扫描器是这个统一架构的基础，扫描器需要基于可变长度切片进行工作  
例如，扫描器将一次读取一个片段的代码，并检查是否下一个片段的开头是否可能组成了一个完整的CHTL或CHTL JS代码片段  
如果组成，说明截断的位置不合理，需要向前扩增，扩增一定的长度  
如果截断的位置合理，则对切片进行根据CHTL / CHTL JS的最小单元进行二次切割，确保结果绝对精确  
例如{{box}}->click将被切割为{{box}}->和click  
CHTL和CHTL JS代码虽然要以最小单元为切割标准，但是仍要基于上下文，确保代码片段不会过小，让多个CHTL和CHTL JS代码片段连续而非全部细分为最小单元  
这样的机制允许JS和CSS编译器在无需特别处理的情况下支持CHTL和CHTL JS的特征  
后续会说明相关方面的约束  

下一步，回顾原先创建的所有文件，严格根据CHTL语法文档.md，不得私自扩展，出现语法偏差，完善CHTL和CHTL JS的Token，GlobalMap，State，Context，Lexer，并编译测试  

回顾原先创建的所有文件，回顾原有架构，严格根据CHTL语法文档.md，不得私自扩展，出现语法偏差，实现CHTL和CHTL JS的AST节点  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md，不得私自扩展，出现语法偏差，创建todo列表，创建CHTL与CHTL JS的解析器以及生成器  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，创建RAII自动化管理模式的状态机 + 上下文管理的协助器，用于标记AST节点的状态，为解析器和生成器提供更精确的状态  
为CHTL和CHTL JS的编译器引入此模式，与扫描器搭配使用  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，完成下述任务，要保证完成且能正常运行  

增强Import功能，修正同一路径表达方式不同，循环依赖，重复导入

对于@Html，@Style，@JavaScript等导入语法，如果没有as语法，则直接跳过
如果有as语法，创建对应类型的带名原始嵌入节点

对于@Html，@Style，@JavaScript等导入语法，如果路径是文件名(不带后缀名)，则直接在编译文件所在的目录(不深入递归)进行搜索，根据类型查找相关的文件
如果路径是具体的文件名(带后缀名)，则直接在编译文件所在的目录(不深入递归)进行搜索此文件
如果路径是文件夹，则直接报错，如果路径指向了具体的文件，则根据此路径来获取文件

对于@Chtl导入语法
路径搜索如下，如果写的只是名称(不带后缀名)，则先在官方模块(源码编译编译器后会生成一个module文件夹，里面存放着编译src/Module好的cmod和cjmod文件)中搜索chtl和cmod文件，如果没有找到，则在当前目录的module文件夹中搜索cmod和chtl文件，cmod优先
如果还是没有，则在当前目录下寻找cmod和chtl文件，cmod优先
如果写了具体的名称(带后缀名)，则先在官方模块(源码编译编译器后会生成一个module文件夹，里面存放着编译src/Module好的cmod和cjmod文件)中搜索该名称的具体文件，如果没有找到，则在当前目录的module文件夹中搜索该名称的具体文件，如果还是没有，则在当前目录下寻找该名称的具体文件
如果写了具体路径(具体文件信息)，则直接在该路径下寻找该文件，如果没有找到，则报错
如果写了具体路径(不具有文件信息)，报错

对于@CJmod导入语法
路径搜索如下，如果写的只是名称(不带后缀名)，则先在官方模块(源码编译编译器后会生成一个module文件夹，里面存放着编译src/Module好的cjmod文件)中搜索cjmod文件，如果没有找到，则在当前目录的module文件夹中搜索cjmod文件
如果还是没有，则在当前目录下寻找cjmod文件
如果写了具体的名称(带后缀名)，则先在官方模块(源码编译编译器后会生成一个module文件夹，里面存放着编译src/Module好的cjmod文件)中搜索该名称的具体文件，如果没有找到，则在当前目录的module文件夹中搜索该名称的具体文件，如果还是没有，则在当前目录下寻找该名称的具体文件
如果写了具体路径(具体文件信息)，则直接在该路径下寻找该文件，如果没有找到，则报错
如果写了具体路径(不具有文件信息)，报错

[Import] @Chtl from 具体路径.*  // 导入具体路径下的所有cmod和chtl文件
[Import] @Chtl from 具体路径.*.cmod  // 导入具体路径下的所有cmod文件
[Import] @Chtl from 具体路径.*.chtl  // 导入具体路径下的所有chtl文件
等价于
[Import] @Chtl from 具体路径/*  // 导入具体路径下的所有cmod和chtl文件
[Import] @Chtl from 具体路径/*.cmod  // 导入具体路径下的所有cmod文件
[Import] @Chtl from 具体路径/*.chtl  // 导入具体路径下的所有chtl文件

// 导入子模块，实际上也可以使用'/'而不是'.'
[Import] @Chtl from Chtholly.*  // 导入Chtholly模块所有子模块
[Import] @Chtl from Chtholly.Space  // 导入Chtholly模块具体的子模块

[Import] @CJmod from 模块名称

CJmod与Cmod使用同种路径搜索策略  

增强命名空间功能，采用同名命名空间合并，冲突检测策略  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，实现Cmod体系，包括但不限于，打包符合格式的文件夹，解包Cmod文件夹，允许引入外部库，如Zip库，如果能够手写简单Zip库也可以  
把功能集成于编译器  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，实现CJmod体系，包括但不限于，打包符合格式的文件夹，解包Cmod文件夹，允许引入外部库，如Zip库，如果能够手写简单Zip库也可以  
把功能集成于编译器  
CJmod体系是开发者通过CHTL JS编译器暴露的接口扩展CHTL JS功能的重要体系，是CHTL编程语言最重要的体系之一  
CJmod体系需要开发者使用C++进行开发，通过预设的方法以及一定的接口，实现无限的JS语法，就像V8引擎那样  

创建官方模块前缀chtl::，允许使用chtl::模块明确使用官方模块  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，分为8次工作todo，列出并完整完成第一部分todo  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，借助状态机，扫描器，上下文，完整完成第二todo  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，借助状态机，扫描器，上下文，完整完成第三todo  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，借助状态机，扫描器，上下文，完整完成第四todo  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，借助状态机，扫描器，上下文，完整完成第五todo  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，借助状态机，扫描器，上下文，完整完成第六todo  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，借助状态机，扫描器，上下文，完整完成第七todo  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法，不得私自扩展，出现语法偏差，借助状态机，扫描器，上下文，完整完成第八todo  

回顾原先创建的所有文件，回顾原有架构, ，查看CHTL语法文档，使用状态机，上下文等已经编写好的架构，让CHTL能够解析语法并生成语法，每一次todo都不能遗留问题，必须在一次todo内解决所有问题，不得遗留问题，完成第三个todo  

回顾原先创建的所有文件，回顾原有架构, 下一步是构建约束器，明确CHTL和CHTL JS语法的边界，首先，全局样式块只能允许模板变量的使用，自定义变量的使用，自定义变量的特例化，模板样式组，自定义样式组，无值样式组，自定义样式组的特例化，delete属性，delete继承，继承(样式组之间的继承)，生成器注释，全缀名，任意类型的原始嵌入(原始嵌入本身就是什么地方都可以使用)，从命名空间中拿到某一个模板变量，自定义变量，模板样式组，自定义样式组，无值样式组...(即from，具体需要查看文档和上述推测)  

回顾原先创建的所有文件，回顾原有架构, 除了局部script外，其他script禁止使用任何CHTL语法，通常为模板变量，自定义变量组，变量组特例化，命名空间from，特别允许的存在是--注释以及原始嵌入(任意类型)

回顾原先创建的所有文件，回顾原有架构, 对于局部样式块来说，能够使用的模板变量的使用，自定义变量的使用，自定义变量的特例化，模板样式组，自定义样式组，无值样式组，自定义样式组的特例化，delete属性，delete继承，继承(样式组之间的继承)，生成器注释，全缀名，任意类型的原始嵌入(原始嵌入本身就是什么地方都可以使用)，从命名空间中拿到某一个模板变量，自定义变量，模板样式组，自定义样式组，无值样式组  

回顾原先创建的所有文件，回顾原有架构, 对于局部script，允许使用模板变量，自定义变量组，变量组特例化，命名空间from，--注释以及原始嵌入(任意类型)，--注释和原始嵌入都是特殊的存在，任意地方都可以写，这里说的是CHTL的语法，{{&}}这些特供语法属于本身具有的功能，不应该被误禁  

回顾原先创建的所有文件，回顾原有架构, 严格根据CHTL语法文档.md中的语法(即下述语法)，不得私自扩展，出现语法偏差，完成以下任务  

下载ANTLR4源代码，手动构建ANTLR4，生成Lnuix和Windows平台的文件，并作为包含包传入仓库之中包含  
接着使用ANTLR4完成CSS和JS编译器的代码  

我忘记说明了CJMOD需要辅助扫描机制，分别是双指针扫描和前置截取，这是因为CJMOD的代码总是以片段出现       │
│   ，双指针扫描是一开始两个指针同时位于0位置，然后预先扫描一个片段是否存在关键字，没有就移动前指针到      │
│   合适的位置，然后类似滑动窗口算法同步向前，如果前指针遇到了关键字，就通知后指针准备收集，确保语法       │
│   片段能够成功返回CJMOD，使其正确填充参数，前置截取是另一种扫描方式，传统扫描器无法处理arg **            │
│   arg2这样的语法片段，因为关键字是**，前面的片段会被扫描并切分到片段之中，前置截取就要截取回来，避       │
│   免将语法发送给编译器，引发错误，这两种扫描方式是我的想法，如果你有更好的选择可以使用你的方法    
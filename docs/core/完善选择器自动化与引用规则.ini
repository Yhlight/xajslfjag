完善选择器自动化与引用规则

现在，你可以在[Configuration]之中添加下述规则禁用自动化  

[Configuration]
{
    // 禁止局部样式块自动添加类选择器
    DISABLE_STYLE_AUTO_ADD_CLASS = false;
    // 禁止局部样式块自动添加id选择器
    DISABLE_STYLE_AUTO_ADD_ID = false;
    // 禁止局部脚本自动添加类选择器
    DISABLE_SCRIPT_AUTO_ADD_CLASS = true;
    // 禁止局部脚本自动添加id选择器
    DISABLE_SCRIPT_AUTO_ADD_ID = true;
}

当局部style内部存在多组类选择器时，若class属性缺失，则自动添加第一个类选择器  
当局部style内部存在多组id选择器时，若id属性缺失，则自动添加第一个id选择器  
对于局部style来说，& 引用选择器优先选择class  

// 如果DISABLE_SCRIPT_AUTO_ADD_CLASS 和 DISABLE_SCRIPT_AUTO_ADD_ID 为真  
当局部script内部存在多组类选择器时，若class属性，局部style没有触发class自动化添加缺失，第一个{{.box}}会被自动添加  
当局部script内部存在多组id选择器时，若id属性，局部style没有触发id自动化添加缺失，第一个{{#box}}会被自动添加  
{{box}}不会自动添加，只有{{.box}}和{{#box}}能够触发自动化添加  
对于局部script来说，& 引用选择器优先选择id  

增强Import功能，修正同一路径多表达方式、循环依赖及重复导入问题，并按以下规则处理各类导入语法，[Import]应该支持无修饰字符串  
对于@Html，@Style，@JavaScript  
这些类型表示导入相应的文件  
如果它们没有使用as语法，则应该直接跳过  
如果它们使用as语法，则应该创建相应类型的带名原始嵌入节点，注意，这和原始嵌入不同，原始嵌入明确表明了使用[Origin]前缀，不要误解自定义原始嵌入类型会导入对应后缀的文件    
例如  
[Import] @Html from "index.html"  // 没有as语法，则跳过  
[Import] @Html from "index.html" as index  // 创建对应类型的带名原始嵌入节点  
[Import] @Vue from "index.vue"  // 不存在的类型，报错或跳过  
[Import] [Origin] @Vue from "xx.chtl"  // 正确的原始嵌入导入方式，且是自定义原始嵌入类型  

对于上述类型的路径搜索如下  
如果写的是文件名（不带后缀）：在编译文件所在目录（非递归）按类型搜索相关文件  
具体文件名（带后缀）：在编译文件所在目录（非递归）直接搜索该文件  
如果路径为文件夹或不包含具体文件信息时，触发报错。  

对于@Chtl类型来说  
名称（不带后缀）：优先搜索官方模块目录(源码编译后生成的module文件夹，通常和编译器同一个文件夹，含cmod，chtl和cjmod文件），其次搜索编译文件所在的目录module文件夹，最后搜索编译文件所在目录，优先匹配cmod文件，其次chtl，不匹配cjmod文件)
具体名称（带后缀）：按官方模块目录→当前目录module文件夹→当前目录顺序搜索指定文件
具体路径（含文件信息）：直接按路径查找，未找到则报错
具体路径（不含文件信息）：触发报错
对于使用官方模块前缀，直接在官方模块目录中搜索  

对于@CJmod类型来说  
名称（不带后缀）：优先搜索官方模块目录，其次搜索当前目录module文件夹，最后搜索当前目录，仅匹配cjmod文件  
具体名称（带后缀）：按官方模块目录→当前目录module文件夹→当前目录顺序搜索指定文件  
具体路径（含文件信息）：直接按路径查找，未找到则报错  
具体路径（不含文件信息）：触发报错
对于使用官方模块前缀，直接在官方模块目录中搜索  

编译生成的module文件夹(官方模块)有两种结构，一种就是常规的混杂，chtl文件，cmod，cjmod  
一种是使用CMOD(包括chtl文件) / CJMOD两个文件夹进行分类  
默认情况都使用CMOD(包括chtl文件) / CJMOD两个文件夹进行分类  

对于用户来说，他们创建的module文件夹也能够使用CMOD(包括chtl文件) / CJMOD两个文件夹进行分类  
值得一提，源代码目录下的模块源码目录Modules也可以使用CMOD(包括chtl文件) / CJMOD两个文件夹进行分类，先前是不支持的  

[Import] @Chtl from 具体路径.*  // 导入具体路径下的所有.cmod和.chtl文件  
[Import] @Chtl from 具体路径.*.cmod  // 导入具体路径下的所有.cmod文件  
[Import] @Chtl from 具体路径.*.chtl  // 导入具体路径下的所有.chtl文件  
等价于
[Import] @Chtl from 具体路径/*  // 导入具体路径下的所有.cmod和.chtl文件  
[Import] @Chtl from 具体路径/*.cmod  // 导入具体路径下的所有.cmod文件  
[Import] @Chtl from 具体路径/*.chtl  // 导入具体路径下的所有.chtl文件  

// 导入子模块时，支持使用'/'替代'.'作为路径分隔符  
[Import] @Chtl from Chtholly.*  // 导入Chtholly模块的所有子模块  
[Import] @Chtl from Chtholly.Space  // 导入Chtholly模块中指定的Space子模块  

[Import] @CJmod from 模块名称  // 导入指定名称的CJmod模块  

CJmod与Cmod采用相同的路径搜索策略。  

至于其他类型，看语法文档即可  

命名空间功能增强说明：
1. 实现同名命名空间自动合并机制；
2. 集成命名空间冲突检测策略。
3. 对于没有使用命名空间的文件，在被导入时，会默认以文件名作为命名空间  // 属于语法的内容，可能已经实现，只是提醒
4. 你可以在[Configuration]之中添加下述规则禁用默认命名空间功能，这意味着导入时可能会造成污染    
[Configuration]
{
    DISABLE_DEFAULT_NAMESPACE = false;
}

接着是让CHTL JS所有使用JS事件的函数支持所有的JS事件  
然后为CHTL JS使用键值对的函数添加键值对无序与可选功能，这将极大扩展了CHTL JS函数的灵活性    
再然后，为CHTL JS添加无修饰字面量支持，无修饰字面量不能单独作为统一扫描器的判断条件  


再之后，是[Origin]和"--"注释的特别说明  
[Origin]原始嵌入节点任意地方都可以使用，不应该被束缚，问题由开发者自己控制  
"--"注释会根据上下文生成不同编程语言的注释  
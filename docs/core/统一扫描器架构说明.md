# 统一扫描器架构说明

## 概述

CHTLUnifiedScanner是CHTL编译器系统的核心组件之一，负责智能识别和分割混合语言代码。它能够准确地将包含CHTL、CHTL JS、CSS和原生JavaScript的源代码分割为相应的代码片段，并将它们路由到对应的编译器进行处理。

## 架构设计

### 🏗️ **系统架构图**

```
                    源代码输入
                        ↓
            ┌─────────────────────────┐
            │   CHTLUnifiedScanner   │
            │   ┌─────────────────┐   │
            │   │  TokenStream    │   │ ← 词法分析流
            │   └─────────────────┘   │
            │   ┌─────────────────┐   │
            │   │  ContextStack   │   │ ← 上下文堆栈
            │   └─────────────────┘   │
            │   ┌─────────────────┐   │
            │   │ LanguageDetector│   │ ← 语言检测器
            │   └─────────────────┘   │
            │   ┌─────────────────┐   │
            │   │  CodeSegmenter  │   │ ← 代码分割器
            │   └─────────────────┘   │
            └─────────────────────────┘
                        ↓
            ┌─────────────────────────┐
            │   CompilerDispatcher   │
            └─────────────────────────┘
                        ↓
        ┌─────────┬─────────┬─────────┬─────────┐
        │  CHTL   │CHTL JS  │   CSS   │   JS    │
        │Compiler │Compiler │Compiler │Compiler │
        └─────────┴─────────┴─────────┴─────────┘
```

### 🧩 **核心组件**

#### 1. TokenStream (令牌流)
负责将源代码转换为令牌流，为后续分析提供基础。

```cpp
// src/Scanner/TokenStream.h
class TokenStream {
private:
    std::vector<Token> tokens_;
    size_t current_position_;
    std::string source_code_;
    
public:
    TokenStream(const std::string& source);
    
    Token peek(size_t offset = 0) const;
    Token advance();
    bool isAtEnd() const;
    void reset();
    
    // 上下文感知的令牌识别
    Token scanNextToken();
    TokenType identifyTokenType(const std::string& text, Context context);
    
private:
    // 字符级别扫描
    char peekChar(size_t offset = 0) const;
    char advanceChar();
    void skipWhitespace();
    void skipComment();
    
    // 特殊语法识别
    Token scanString();
    Token scanNumber();
    Token scanIdentifier();
    Token scanOperator();
    Token scanCHTLJSFunction();
};
```

#### 2. ContextStack (上下文堆栈)
管理嵌套的语言上下文，确保正确识别语言边界。

```cpp
// src/Scanner/ContextStack.h
enum class LanguageContext {
    CHTL,           // CHTL主语言
    CHTL_JS,        // CHTL JS扩展
    CSS,            // CSS样式
    JavaScript,     // 原生JavaScript
    HTML,           // 原始HTML
    String,         // 字符串字面量
    Comment,        // 注释
    Template        // 模板字面量
};

class ContextStack {
private:
    std::stack<ContextFrame> context_stack_;
    LanguageContext current_context_;
    
public:
    void pushContext(LanguageContext context, const SourceLocation& location);
    void popContext();
    LanguageContext getCurrentContext() const;
    
    // 上下文查询
    bool isInContext(LanguageContext context) const;
    bool isInNestedContext() const;
    std::vector<LanguageContext> getContextChain() const;
    
    // 上下文切换检测
    bool shouldSwitchContext(const Token& token) const;
    LanguageContext detectTargetContext(const Token& token) const;
    
private:
    struct ContextFrame {
        LanguageContext context;
        SourceLocation start_location;
        std::unordered_map<std::string, std::string> context_data;
    };
};
```

#### 3. LanguageDetector (语言检测器)
智能检测代码片段的语言类型。

```cpp
// src/Scanner/LanguageDetector.h
class LanguageDetector {
private:
    // 语言特征模式
    std::vector<LanguagePattern> chtl_patterns_;
    std::vector<LanguagePattern> chtljs_patterns_;
    std::vector<LanguagePattern> css_patterns_;
    std::vector<LanguagePattern> js_patterns_;
    
public:
    LanguageDetector();
    
    // 主要检测接口
    LanguageContext detectLanguage(const TokenStream& tokens, size_t start_pos) const;
    LanguageContext detectLanguageFromKeyword(const std::string& keyword) const;
    
    // 置信度检测
    struct DetectionResult {
        LanguageContext language;
        float confidence;
        std::vector<std::string> detected_features;
    };
    
    DetectionResult analyzeCodeSegment(const std::string& code) const;
    
private:
    struct LanguagePattern {
        std::regex pattern;
        LanguageContext target_language;
        float weight;
        std::string description;
    };
    
    void initializeCHTLPatterns();
    void initializeCHTLJSPatterns();
    void initializeCSSPatterns();
    void initializeJSPatterns();
    
    float calculatePatternScore(const std::string& code, 
                               const std::vector<LanguagePattern>& patterns) const;
};
```

## 关键算法

### 🔍 **语言检测算法**

#### 1. 关键字优先检测
```cpp
LanguageContext LanguageDetector::detectLanguageFromKeyword(const std::string& keyword) const {
    // CHTL关键字
    static const std::unordered_set<std::string> chtl_keywords = {
        "div", "span", "p", "h1", "h2", "h3", "h4", "h5", "h6",
        "Template", "Custom", "Configuration", "Import", "use",
        "delete", "insert", "except"
    };
    
    // CHTL JS关键字
    static const std::unordered_set<std::string> chtljs_keywords = {
        "listen", "delegate", "animate", "vir",
        "await>>", "parallel>>", "timeout>>", "retry>>"
    };
    
    // CSS关键字
    static const std::unordered_set<std::string> css_keywords = {
        "style", "class", "id", "hover", "active", "focus",
        "display", "position", "width", "height", "margin", "padding"
    };
    
    if (chtl_keywords.find(keyword) != chtl_keywords.end()) {
        return LanguageContext::CHTL;
    } else if (chtljs_keywords.find(keyword) != chtljs_keywords.end()) {
        return LanguageContext::CHTL_JS;
    } else if (css_keywords.find(keyword) != css_keywords.end()) {
        return LanguageContext::CSS;
    }
    
    return LanguageContext::JavaScript;  // 默认为JavaScript
}
```

#### 2. 模式匹配检测
```cpp
void LanguageDetector::initializeCHTLPatterns() {
    chtl_patterns_ = {
        // 元素语法: element.class#id { ... }
        {std::regex(R"(\w+(\.\w+)*(#\w+)?\s*\{)"), LanguageContext::CHTL, 0.9f, "Element syntax"},
        
        // 模板语法: [Template] @Type Name { ... }
        {std::regex(R"(\[Template\]\s*@\w+\s+\w+\s*\{)"), LanguageContext::CHTL, 0.95f, "Template syntax"},
        
        // 配置语法: [Configuration] { ... }
        {std::regex(R"(\[Configuration\]\s*\{)"), LanguageContext::CHTL, 0.9f, "Configuration syntax"},
        
        // 导入语法: Import @Type from Module
        {std::regex(R"(Import\s+@\w+\s+from\s+\w+)"), LanguageContext::CHTL, 0.85f, "Import syntax"},
        
        // 特例化操作: delete/insert/except
        {std::regex(R"((delete|insert|except)\s+\w+)"), LanguageContext::CHTL, 0.8f, "Specialization operations"}
    };
}

void LanguageDetector::initializeCHTLJSPatterns() {
    chtljs_patterns_ = {
        // listen语法: listen name = { ... }
        {std::regex(R"(listen\s+\w+\s*=\s*\{)"), LanguageContext::CHTL_JS, 0.95f, "Listen syntax"},
        
        // 事件绑定: {{selector}} &-> event { ... }
        {std::regex(R"(\{\{[^}]+\}\}\s*&->\s*\w+\s*\{)"), LanguageContext::CHTL_JS, 0.9f, "Event binding"},
        
        // 异步语法: await>> expr >> expr
        {std::regex(R"(await>>\s*[^>]+>>)"), LanguageContext::CHTL_JS, 0.85f, "Async chain syntax"},
        
        // 并行语法: parallel>> [...]
        {std::regex(R"(parallel>>\s*\[)"), LanguageContext::CHTL_JS, 0.85f, "Parallel syntax"},
        
        // 虚对象: vir name = ...
        {std::regex(R"(vir\s+\w+\s*=)"), LanguageContext::CHTL_JS, 0.8f, "Virtual object syntax"},
        
        // 响应式绑定: <->, =>, ?:, *:, ~>, |>
        {std::regex(R"((<->|=>|\?:|\*:|~>|\|>))"), LanguageContext::CHTL_JS, 0.7f, "Reactive binding"}
    };
}
```

#### 3. 统计特征检测
```cpp
DetectionResult LanguageDetector::analyzeCodeSegment(const std::string& code) const {
    DetectionResult result;
    
    // 计算各语言的特征得分
    float chtl_score = calculatePatternScore(code, chtl_patterns_);
    float chtljs_score = calculatePatternScore(code, chtljs_patterns_);
    float css_score = calculatePatternScore(code, css_patterns_);
    float js_score = calculatePatternScore(code, js_patterns_);
    
    // 附加启发式检测
    
    // 检测CSS特征
    if (code.find(':') != std::string::npos && code.find(';') != std::string::npos) {
        css_score += 0.3f;
    }
    
    // 检测JavaScript特征
    if (code.find("function") != std::string::npos || 
        code.find("var ") != std::string::npos ||
        code.find("const ") != std::string::npos ||
        code.find("let ") != std::string::npos) {
        js_score += 0.4f;
    }
    
    // 检测CHTL特征
    if (code.find('{') != std::string::npos && 
        code.find('}') != std::string::npos &&
        std::regex_search(code, std::regex(R"(\w+\s*\{)"))) {
        chtl_score += 0.2f;
    }
    
    // 确定最高得分的语言
    float max_score = std::max({chtl_score, chtljs_score, css_score, js_score});
    
    if (max_score == chtl_score) {
        result.language = LanguageContext::CHTL;
    } else if (max_score == chtljs_score) {
        result.language = LanguageContext::CHTL_JS;
    } else if (max_score == css_score) {
        result.language = LanguageContext::CSS;
    } else {
        result.language = LanguageContext::JavaScript;
    }
    
    result.confidence = max_score;
    return result;
}
```

### ✂️ **代码分割算法**

#### 1. 上下文感知分割
```cpp
// src/Scanner/CodeSegmenter.h
class CodeSegmenter {
private:
    TokenStream token_stream_;
    ContextStack context_stack_;
    LanguageDetector language_detector_;
    
public:
    struct CodeSegment {
        LanguageContext language;
        std::string content;
        SourceLocation start_location;
        SourceLocation end_location;
        std::unordered_map<std::string, std::string> metadata;
    };
    
    std::vector<CodeSegment> segmentCode(const std::string& source_code);
    
private:
    CodeSegment extractSegment(LanguageContext language, 
                              size_t start_pos, 
                              size_t end_pos);
    
    bool isSegmentBoundary(const Token& token) const;
    size_t findSegmentEnd(LanguageContext language, size_t start_pos);
    
    // 特定语言的分割逻辑
    size_t findCHTLSegmentEnd(size_t start_pos);
    size_t findCHTLJSSegmentEnd(size_t start_pos);
    size_t findCSSSegmentEnd(size_t start_pos);
    size_t findJSSegmentEnd(size_t start_pos);
};

std::vector<CodeSegment> CodeSegmenter::segmentCode(const std::string& source_code) {
    std::vector<CodeSegment> segments;
    token_stream_ = TokenStream(source_code);
    
    while (!token_stream_.isAtEnd()) {
        Token current_token = token_stream_.peek();
        
        // 检测语言上下文
        LanguageContext detected_language = language_detector_.detectLanguage(
            token_stream_, token_stream_.getCurrentPosition());
        
        // 如果语言上下文改变，创建新段
        if (context_stack_.getCurrentContext() != detected_language) {
            if (!context_stack_.isInNestedContext()) {
                context_stack_.pushContext(detected_language, current_token.location);
            }
        }
        
        // 确定段结束位置
        size_t start_pos = token_stream_.getCurrentPosition();
        size_t end_pos = findSegmentEnd(detected_language, start_pos);
        
        // 创建代码段
        CodeSegment segment = extractSegment(detected_language, start_pos, end_pos);
        segments.push_back(segment);
        
        // 移动到下一个段
        token_stream_.setPosition(end_pos);
        context_stack_.popContext();
    }
    
    return segments;
}
```

#### 2. 嵌套语言处理
```cpp
size_t CodeSegmenter::findCHTLSegmentEnd(size_t start_pos) {
    size_t brace_count = 0;
    size_t current_pos = start_pos;
    bool in_string = false;
    char quote_char = '\0';
    
    while (current_pos < token_stream_.size()) {
        Token token = token_stream_.getToken(current_pos);
        
        // 处理字符串
        if (!in_string && (token.type == TokenType::String)) {
            in_string = true;
            quote_char = token.text[0];
        } else if (in_string && token.text == std::string(1, quote_char)) {
            in_string = false;
            quote_char = '\0';
        }
        
        if (!in_string) {
            // 检测嵌套的script块
            if (token.type == TokenType::Identifier && token.text == "script") {
                Token next_token = token_stream_.getToken(current_pos + 1);
                if (next_token.type == TokenType::LeftBrace) {
                    // 这是一个script块，需要特殊处理
                    size_t script_end = findNestedScriptEnd(current_pos + 2);
                    current_pos = script_end;
                    continue;
                }
            }
            
            // 处理花括号
            if (token.type == TokenType::LeftBrace) {
                brace_count++;
            } else if (token.type == TokenType::RightBrace) {
                brace_count--;
                if (brace_count == 0) {
                    return current_pos + 1;  // 包含结束花括号
                }
            }
        }
        
        current_pos++;
    }
    
    return current_pos;
}

size_t CodeSegmenter::findNestedScriptEnd(size_t start_pos) {
    size_t brace_count = 1;  // 已经遇到开始的花括号
    size_t current_pos = start_pos;
    
    while (current_pos < token_stream_.size() && brace_count > 0) {
        Token token = token_stream_.getToken(current_pos);
        
        if (token.type == TokenType::LeftBrace) {
            brace_count++;
        } else if (token.type == TokenType::RightBrace) {
            brace_count--;
        }
        
        current_pos++;
    }
    
    return current_pos;
}
```

## 统一扫描器实现

### 🔄 **主扫描流程**

```cpp
// src/Scanner/CHTLUnifiedScanner.h
class CHTLUnifiedScanner {
private:
    TokenStream token_stream_;
    ContextStack context_stack_;
    LanguageDetector language_detector_;
    CodeSegmenter code_segmenter_;
    
    // 扫描状态
    ScannerState current_state_;
    std::unordered_map<std::string, std::string> scanner_options_;
    
public:
    CHTLUnifiedScanner();
    
    // 主要接口
    ScanResult scan(const std::string& source_code);
    ScanResult scanFile(const std::string& file_path);
    
    // 配置接口
    void setOption(const std::string& key, const std::string& value);
    void enableDebugMode(bool enable);
    void setLanguagePriority(const std::vector<LanguageContext>& priority);
    
private:
    // 内部扫描方法
    void preprocessSource(std::string& source);
    void initializeDetectionPatterns();
    void validateSegments(const std::vector<CodeSegment>& segments);
    
    // 优化方法
    void optimizeSegments(std::vector<CodeSegment>& segments);
    void mergeAdjacentSegments(std::vector<CodeSegment>& segments);
    void resolveAmbiguousSegments(std::vector<CodeSegment>& segments);
};

struct ScanResult {
    bool success;
    std::vector<CodeSegment> segments;
    std::vector<ScanError> errors;
    std::vector<ScanWarning> warnings;
    ScanStatistics statistics;
};

ScanResult CHTLUnifiedScanner::scan(const std::string& source_code) {
    ScanResult result;
    
    try {
        // 1. 预处理源代码
        std::string processed_source = source_code;
        preprocessSource(processed_source);
        
        // 2. 初始化令牌流
        token_stream_ = TokenStream(processed_source);
        
        // 3. 分割代码
        result.segments = code_segmenter_.segmentCode(processed_source);
        
        // 4. 验证分割结果
        validateSegments(result.segments);
        
        // 5. 优化分割结果
        optimizeSegments(result.segments);
        
        // 6. 生成统计信息
        result.statistics = generateStatistics(result.segments);
        
        result.success = true;
        
    } catch (const ScanException& e) {
        result.success = false;
        result.errors.push_back(ScanError{e.what(), e.getLocation()});
    }
    
    return result;
}
```

### 📊 **性能优化**

#### 1. 预编译模式识别
```cpp
class PatternCache {
private:
    std::unordered_map<std::string, LanguageContext> keyword_cache_;
    std::unordered_map<std::string, DetectionResult> pattern_cache_;
    
public:
    void precompilePatterns() {
        // 预编译常用模式
        for (const auto& keyword : common_keywords) {
            keyword_cache_[keyword] = detectLanguageFromKeyword(keyword);
        }
    }
    
    LanguageContext getCachedLanguage(const std::string& keyword) {
        auto it = keyword_cache_.find(keyword);
        return (it != keyword_cache_.end()) ? it->second : LanguageContext::JavaScript;
    }
};
```

#### 2. 并行扫描
```cpp
class ParallelScanner {
public:
    ScanResult parallelScan(const std::string& source_code, size_t thread_count = 4) {
        // 将源代码分块
        std::vector<std::string> chunks = divideIntoChunks(source_code, thread_count);
        
        // 并行扫描每个块
        std::vector<std::future<std::vector<CodeSegment>>> futures;
        for (const auto& chunk : chunks) {
            futures.push_back(std::async(std::launch::async, [this, chunk] {
                return code_segmenter_.segmentCode(chunk);
            }));
        }
        
        // 合并结果
        ScanResult result;
        for (auto& future : futures) {
            auto segments = future.get();
            result.segments.insert(result.segments.end(), segments.begin(), segments.end());
        }
        
        // 合并边界处的段
        mergeBoundarySegments(result.segments);
        
        return result;
    }
};
```

#### 3. 内存池优化
```cpp
class TokenPool {
private:
    std::vector<Token> token_pool_;
    size_t next_available_;
    
public:
    Token* allocateToken() {
        if (next_available_ >= token_pool_.size()) {
            token_pool_.resize(token_pool_.size() * 2);
        }
        return &token_pool_[next_available_++];
    }
    
    void reset() {
        next_available_ = 0;
    }
};
```

## 错误处理和调试

### 🐛 **错误类型**

```cpp
enum class ScanErrorType {
    UnterminatedString,     // 未终结的字符串
    UnterminatedComment,    // 未终结的注释
    UnbalancedBraces,       // 不平衡的花括号
    AmbiguousLanguage,      // 语言检测模糊
    InvalidCharacter,       // 无效字符
    ContextMismatch,        // 上下文不匹配
    SegmentationError       // 分割错误
};

class ScanError {
public:
    ScanErrorType type;
    std::string message;
    SourceLocation location;
    std::string suggestion;
    
    std::string format() const {
        return formatScanError(type, message, location, suggestion);
    }
};
```

### 🔍 **调试工具**

```cpp
class ScannerDebugger {
private:
    bool debug_enabled_;
    std::ofstream debug_log_;
    
public:
    void enableDebug(const std::string& log_file) {
        debug_enabled_ = true;
        debug_log_.open(log_file);
    }
    
    void logTokenStream(const TokenStream& stream) {
        if (!debug_enabled_) return;
        
        debug_log_ << "=== Token Stream ===" << std::endl;
        for (size_t i = 0; i < stream.size(); ++i) {
            Token token = stream.getToken(i);
            debug_log_ << i << ": " << tokenTypeToString(token.type) 
                      << " \"" << token.text << "\" @" 
                      << token.location.line << ":" << token.location.column << std::endl;
        }
    }
    
    void logContextStack(const ContextStack& stack) {
        if (!debug_enabled_) return;
        
        debug_log_ << "=== Context Stack ===" << std::endl;
        auto contexts = stack.getContextChain();
        for (size_t i = 0; i < contexts.size(); ++i) {
            debug_log_ << i << ": " << languageContextToString(contexts[i]) << std::endl;
        }
    }
    
    void logSegments(const std::vector<CodeSegment>& segments) {
        if (!debug_enabled_) return;
        
        debug_log_ << "=== Code Segments ===" << std::endl;
        for (size_t i = 0; i < segments.size(); ++i) {
            const auto& segment = segments[i];
            debug_log_ << "Segment " << i << ": " 
                      << languageContextToString(segment.language) << std::endl;
            debug_log_ << "Content: " << segment.content.substr(0, 100) 
                      << (segment.content.length() > 100 ? "..." : "") << std::endl;
            debug_log_ << "Location: " << segment.start_location.line 
                      << ":" << segment.start_location.column << " - "
                      << segment.end_location.line << ":" << segment.end_location.column << std::endl;
            debug_log_ << "---" << std::endl;
        }
    }
};
```

## 扩展性设计

### 🔌 **插件接口**

```cpp
// 语言检测插件接口
class LanguageDetectorPlugin {
public:
    virtual ~LanguageDetectorPlugin() = default;
    
    virtual std::string getName() const = 0;
    virtual std::vector<std::string> getSupportedLanguages() const = 0;
    virtual DetectionResult detectLanguage(const std::string& code) const = 0;
    virtual void initialize(const PluginConfig& config) = 0;
};

// 代码分割插件接口
class CodeSegmenterPlugin {
public:
    virtual ~CodeSegmenterPlugin() = default;
    
    virtual std::string getName() const = 0;
    virtual bool canHandle(LanguageContext language) const = 0;
    virtual size_t findSegmentEnd(const TokenStream& stream, size_t start_pos) const = 0;
};

// 插件管理器
class PluginManager {
private:
    std::vector<std::unique_ptr<LanguageDetectorPlugin>> detector_plugins_;
    std::vector<std::unique_ptr<CodeSegmenterPlugin>> segmenter_plugins_;
    
public:
    void registerDetectorPlugin(std::unique_ptr<LanguageDetectorPlugin> plugin);
    void registerSegmenterPlugin(std::unique_ptr<CodeSegmenterPlugin> plugin);
    
    DetectionResult detectWithPlugins(const std::string& code);
    size_t segmentWithPlugins(const TokenStream& stream, LanguageContext language, size_t start_pos);
};
```

### 🎯 **自定义语言支持**

```cpp
// 用户可以通过配置文件添加新语言支持
class CustomLanguageConfig {
public:
    struct LanguageDefinition {
        std::string name;
        LanguageContext context;
        std::vector<std::string> keywords;
        std::vector<std::regex> patterns;
        std::string comment_start;
        std::string comment_end;
        char string_delimiter;
        char escape_character;
    };
    
    void loadFromFile(const std::string& config_file);
    void addLanguageDefinition(const LanguageDefinition& definition);
    std::vector<LanguageDefinition> getAllDefinitions() const;
};
```

## 使用示例

### 📝 **基本使用**

```cpp
#include "Scanner/CHTLUnifiedScanner.h"

int main() {
    CHTLUnifiedScanner scanner;
    
    // 启用调试模式
    scanner.enableDebugMode(true);
    
    // 设置语言优先级
    scanner.setLanguagePriority({
        LanguageContext::CHTL,
        LanguageContext::CHTL_JS,
        LanguageContext::CSS,
        LanguageContext::JavaScript
    });
    
    // 扫描源代码
    std::string source_code = R"(
        div.container {
            h1 { "Hello CHTL" }
            
            script {
                listen buttonHandler = {
                    click: () => {
                        console.log('Button clicked');
                    }
                };
                
                {{.btn}} &-> click {
                    buttonHandler->click();
                };
            }
            
            style {
                .container {
                    max-width: 1200px;
                    margin: 0 auto;
                }
                
                .btn {
                    background: #007bff;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 4px;
                }
            }
        }
    )";
    
    ScanResult result = scanner.scan(source_code);
    
    if (result.success) {
        std::cout << "扫描成功！找到 " << result.segments.size() << " 个代码段：" << std::endl;
        
        for (const auto& segment : result.segments) {
            std::cout << "语言: " << languageContextToString(segment.language) << std::endl;
            std::cout << "位置: " << segment.start_location.line << ":" 
                      << segment.start_location.column << " - "
                      << segment.end_location.line << ":" 
                      << segment.end_location.column << std::endl;
            std::cout << "内容预览: " << segment.content.substr(0, 50) << "..." << std::endl;
            std::cout << "---" << std::endl;
        }
        
        // 显示统计信息
        std::cout << "统计信息:" << std::endl;
        std::cout << "CHTL段数: " << result.statistics.chtl_segments << std::endl;
        std::cout << "CHTL JS段数: " << result.statistics.chtljs_segments << std::endl;
        std::cout << "CSS段数: " << result.statistics.css_segments << std::endl;
        std::cout << "JS段数: " << result.statistics.js_segments << std::endl;
        
    } else {
        std::cout << "扫描失败：" << std::endl;
        for (const auto& error : result.errors) {
            std::cout << "错误: " << error.format() << std::endl;
        }
    }
    
    return 0;
}
```

---

统一扫描器是CHTL编译器系统的核心基础设施，它的准确性和性能直接影响到整个编译过程的质量。通过精心设计的语言检测算法和上下文管理机制，统一扫描器能够准确地处理复杂的混合语言代码，为后续的编译阶段提供可靠的输入。
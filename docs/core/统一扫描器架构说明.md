# ç»Ÿä¸€æ‰«æå™¨æ¶æ„è¯´æ˜

## æ¦‚è¿°

CHTLUnifiedScanneræ˜¯CHTLç¼–è¯‘å™¨ç³»ç»Ÿçš„æ ¸å¿ƒç»„ä»¶ä¹‹ä¸€ï¼Œè´Ÿè´£æ™ºèƒ½è¯†åˆ«å’Œåˆ†å‰²æ··åˆè¯­è¨€ä»£ç ã€‚å®ƒèƒ½å¤Ÿå‡†ç¡®åœ°å°†åŒ…å«CHTLã€CHTL JSã€CSSå’ŒåŸç”ŸJavaScriptçš„æºä»£ç åˆ†å‰²ä¸ºç›¸åº”çš„ä»£ç ç‰‡æ®µï¼Œå¹¶å°†å®ƒä»¬è·¯ç”±åˆ°å¯¹åº”çš„ç¼–è¯‘å™¨è¿›è¡Œå¤„ç†ã€‚

## æ¶æ„è®¾è®¡

### ğŸ—ï¸ **ç³»ç»Ÿæ¶æ„å›¾**

```
                    æºä»£ç è¾“å…¥
                        â†“
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   CHTLUnifiedScanner   â”‚
            â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
            â”‚   â”‚  TokenStream    â”‚   â”‚ â† è¯æ³•åˆ†ææµ
            â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
            â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
            â”‚   â”‚  ContextStack   â”‚   â”‚ â† ä¸Šä¸‹æ–‡å †æ ˆ
            â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
            â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
            â”‚   â”‚ LanguageDetectorâ”‚   â”‚ â† è¯­è¨€æ£€æµ‹å™¨
            â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
            â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
            â”‚   â”‚  CodeSegmenter  â”‚   â”‚ â† ä»£ç åˆ†å‰²å™¨
            â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   CompilerDispatcher   â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  CHTL   â”‚CHTL JS  â”‚   CSS   â”‚   JS    â”‚
        â”‚Compiler â”‚Compiler â”‚Compiler â”‚Compiler â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ§© **æ ¸å¿ƒç»„ä»¶**

#### 1. TokenStream (ä»¤ç‰Œæµ)
è´Ÿè´£å°†æºä»£ç è½¬æ¢ä¸ºä»¤ç‰Œæµï¼Œä¸ºåç»­åˆ†ææä¾›åŸºç¡€ã€‚

```cpp
// src/Scanner/TokenStream.h
class TokenStream {
private:
    std::vector<Token> tokens_;
    size_t current_position_;
    std::string source_code_;
    
public:
    TokenStream(const std::string& source);
    
    Token peek(size_t offset = 0) const;
    Token advance();
    bool isAtEnd() const;
    void reset();
    
    // ä¸Šä¸‹æ–‡æ„ŸçŸ¥çš„ä»¤ç‰Œè¯†åˆ«
    Token scanNextToken();
    TokenType identifyTokenType(const std::string& text, Context context);
    
private:
    // å­—ç¬¦çº§åˆ«æ‰«æ
    char peekChar(size_t offset = 0) const;
    char advanceChar();
    void skipWhitespace();
    void skipComment();
    
    // ç‰¹æ®Šè¯­æ³•è¯†åˆ«
    Token scanString();
    Token scanNumber();
    Token scanIdentifier();
    Token scanOperator();
    Token scanCHTLJSFunction();
};
```

#### 2. ContextStack (ä¸Šä¸‹æ–‡å †æ ˆ)
ç®¡ç†åµŒå¥—çš„è¯­è¨€ä¸Šä¸‹æ–‡ï¼Œç¡®ä¿æ­£ç¡®è¯†åˆ«è¯­è¨€è¾¹ç•Œã€‚

```cpp
// src/Scanner/ContextStack.h
enum class LanguageContext {
    CHTL,           // CHTLä¸»è¯­è¨€
    CHTL_JS,        // CHTL JSæ‰©å±•
    CSS,            // CSSæ ·å¼
    JavaScript,     // åŸç”ŸJavaScript
    HTML,           // åŸå§‹HTML
    String,         // å­—ç¬¦ä¸²å­—é¢é‡
    Comment,        // æ³¨é‡Š
    Template        // æ¨¡æ¿å­—é¢é‡
};

class ContextStack {
private:
    std::stack<ContextFrame> context_stack_;
    LanguageContext current_context_;
    
public:
    void pushContext(LanguageContext context, const SourceLocation& location);
    void popContext();
    LanguageContext getCurrentContext() const;
    
    // ä¸Šä¸‹æ–‡æŸ¥è¯¢
    bool isInContext(LanguageContext context) const;
    bool isInNestedContext() const;
    std::vector<LanguageContext> getContextChain() const;
    
    // ä¸Šä¸‹æ–‡åˆ‡æ¢æ£€æµ‹
    bool shouldSwitchContext(const Token& token) const;
    LanguageContext detectTargetContext(const Token& token) const;
    
private:
    struct ContextFrame {
        LanguageContext context;
        SourceLocation start_location;
        std::unordered_map<std::string, std::string> context_data;
    };
};
```

#### 3. LanguageDetector (è¯­è¨€æ£€æµ‹å™¨)
æ™ºèƒ½æ£€æµ‹ä»£ç ç‰‡æ®µçš„è¯­è¨€ç±»å‹ã€‚

```cpp
// src/Scanner/LanguageDetector.h
class LanguageDetector {
private:
    // è¯­è¨€ç‰¹å¾æ¨¡å¼
    std::vector<LanguagePattern> chtl_patterns_;
    std::vector<LanguagePattern> chtljs_patterns_;
    std::vector<LanguagePattern> css_patterns_;
    std::vector<LanguagePattern> js_patterns_;
    
public:
    LanguageDetector();
    
    // ä¸»è¦æ£€æµ‹æ¥å£
    LanguageContext detectLanguage(const TokenStream& tokens, size_t start_pos) const;
    LanguageContext detectLanguageFromKeyword(const std::string& keyword) const;
    
    // ç½®ä¿¡åº¦æ£€æµ‹
    struct DetectionResult {
        LanguageContext language;
        float confidence;
        std::vector<std::string> detected_features;
    };
    
    DetectionResult analyzeCodeSegment(const std::string& code) const;
    
private:
    struct LanguagePattern {
        std::regex pattern;
        LanguageContext target_language;
        float weight;
        std::string description;
    };
    
    void initializeCHTLPatterns();
    void initializeCHTLJSPatterns();
    void initializeCSSPatterns();
    void initializeJSPatterns();
    
    float calculatePatternScore(const std::string& code, 
                               const std::vector<LanguagePattern>& patterns) const;
};
```

## å…³é”®ç®—æ³•

### ğŸ” **è¯­è¨€æ£€æµ‹ç®—æ³•**

#### 1. å…³é”®å­—ä¼˜å…ˆæ£€æµ‹
```cpp
LanguageContext LanguageDetector::detectLanguageFromKeyword(const std::string& keyword) const {
    // CHTLå…³é”®å­—
    static const std::unordered_set<std::string> chtl_keywords = {
        "div", "span", "p", "h1", "h2", "h3", "h4", "h5", "h6",
        "Template", "Custom", "Configuration", "Import", "use",
        "delete", "insert", "except"
    };
    
    // CHTL JSå…³é”®å­—
    static const std::unordered_set<std::string> chtljs_keywords = {
        "listen", "delegate", "animate", "vir",
        "await>>", "parallel>>", "timeout>>", "retry>>"
    };
    
    // CSSå…³é”®å­—
    static const std::unordered_set<std::string> css_keywords = {
        "style", "class", "id", "hover", "active", "focus",
        "display", "position", "width", "height", "margin", "padding"
    };
    
    if (chtl_keywords.find(keyword) != chtl_keywords.end()) {
        return LanguageContext::CHTL;
    } else if (chtljs_keywords.find(keyword) != chtljs_keywords.end()) {
        return LanguageContext::CHTL_JS;
    } else if (css_keywords.find(keyword) != css_keywords.end()) {
        return LanguageContext::CSS;
    }
    
    return LanguageContext::JavaScript;  // é»˜è®¤ä¸ºJavaScript
}
```

#### 2. æ¨¡å¼åŒ¹é…æ£€æµ‹
```cpp
void LanguageDetector::initializeCHTLPatterns() {
    chtl_patterns_ = {
        // å…ƒç´ è¯­æ³•: element.class#id { ... }
        {std::regex(R"(\w+(\.\w+)*(#\w+)?\s*\{)"), LanguageContext::CHTL, 0.9f, "Element syntax"},
        
        // æ¨¡æ¿è¯­æ³•: [Template] @Type Name { ... }
        {std::regex(R"(\[Template\]\s*@\w+\s+\w+\s*\{)"), LanguageContext::CHTL, 0.95f, "Template syntax"},
        
        // é…ç½®è¯­æ³•: [Configuration] { ... }
        {std::regex(R"(\[Configuration\]\s*\{)"), LanguageContext::CHTL, 0.9f, "Configuration syntax"},
        
        // å¯¼å…¥è¯­æ³•: Import @Type from Module
        {std::regex(R"(Import\s+@\w+\s+from\s+\w+)"), LanguageContext::CHTL, 0.85f, "Import syntax"},
        
        // ç‰¹ä¾‹åŒ–æ“ä½œ: delete/insert/except
        {std::regex(R"((delete|insert|except)\s+\w+)"), LanguageContext::CHTL, 0.8f, "Specialization operations"}
    };
}

void LanguageDetector::initializeCHTLJSPatterns() {
    chtljs_patterns_ = {
        // listenè¯­æ³•: listen name = { ... }
        {std::regex(R"(listen\s+\w+\s*=\s*\{)"), LanguageContext::CHTL_JS, 0.95f, "Listen syntax"},
        
        // äº‹ä»¶ç»‘å®š: {{selector}} &-> event { ... }
        {std::regex(R"(\{\{[^}]+\}\}\s*&->\s*\w+\s*\{)"), LanguageContext::CHTL_JS, 0.9f, "Event binding"},
        
        // å¼‚æ­¥è¯­æ³•: await>> expr >> expr
        {std::regex(R"(await>>\s*[^>]+>>)"), LanguageContext::CHTL_JS, 0.85f, "Async chain syntax"},
        
        // å¹¶è¡Œè¯­æ³•: parallel>> [...]
        {std::regex(R"(parallel>>\s*\[)"), LanguageContext::CHTL_JS, 0.85f, "Parallel syntax"},
        
        // è™šå¯¹è±¡: vir name = ...
        {std::regex(R"(vir\s+\w+\s*=)"), LanguageContext::CHTL_JS, 0.8f, "Virtual object syntax"},
        
        // å“åº”å¼ç»‘å®š: <->, =>, ?:, *:, ~>, |>
        {std::regex(R"((<->|=>|\?:|\*:|~>|\|>))"), LanguageContext::CHTL_JS, 0.7f, "Reactive binding"}
    };
}
```

#### 3. ç»Ÿè®¡ç‰¹å¾æ£€æµ‹
```cpp
DetectionResult LanguageDetector::analyzeCodeSegment(const std::string& code) const {
    DetectionResult result;
    
    // è®¡ç®—å„è¯­è¨€çš„ç‰¹å¾å¾—åˆ†
    float chtl_score = calculatePatternScore(code, chtl_patterns_);
    float chtljs_score = calculatePatternScore(code, chtljs_patterns_);
    float css_score = calculatePatternScore(code, css_patterns_);
    float js_score = calculatePatternScore(code, js_patterns_);
    
    // é™„åŠ å¯å‘å¼æ£€æµ‹
    
    // æ£€æµ‹CSSç‰¹å¾
    if (code.find(':') != std::string::npos && code.find(';') != std::string::npos) {
        css_score += 0.3f;
    }
    
    // æ£€æµ‹JavaScriptç‰¹å¾
    if (code.find("function") != std::string::npos || 
        code.find("var ") != std::string::npos ||
        code.find("const ") != std::string::npos ||
        code.find("let ") != std::string::npos) {
        js_score += 0.4f;
    }
    
    // æ£€æµ‹CHTLç‰¹å¾
    if (code.find('{') != std::string::npos && 
        code.find('}') != std::string::npos &&
        std::regex_search(code, std::regex(R"(\w+\s*\{)"))) {
        chtl_score += 0.2f;
    }
    
    // ç¡®å®šæœ€é«˜å¾—åˆ†çš„è¯­è¨€
    float max_score = std::max({chtl_score, chtljs_score, css_score, js_score});
    
    if (max_score == chtl_score) {
        result.language = LanguageContext::CHTL;
    } else if (max_score == chtljs_score) {
        result.language = LanguageContext::CHTL_JS;
    } else if (max_score == css_score) {
        result.language = LanguageContext::CSS;
    } else {
        result.language = LanguageContext::JavaScript;
    }
    
    result.confidence = max_score;
    return result;
}
```

### âœ‚ï¸ **ä»£ç åˆ†å‰²ç®—æ³•**

#### 1. ä¸Šä¸‹æ–‡æ„ŸçŸ¥åˆ†å‰²
```cpp
// src/Scanner/CodeSegmenter.h
class CodeSegmenter {
private:
    TokenStream token_stream_;
    ContextStack context_stack_;
    LanguageDetector language_detector_;
    
public:
    struct CodeSegment {
        LanguageContext language;
        std::string content;
        SourceLocation start_location;
        SourceLocation end_location;
        std::unordered_map<std::string, std::string> metadata;
    };
    
    std::vector<CodeSegment> segmentCode(const std::string& source_code);
    
private:
    CodeSegment extractSegment(LanguageContext language, 
                              size_t start_pos, 
                              size_t end_pos);
    
    bool isSegmentBoundary(const Token& token) const;
    size_t findSegmentEnd(LanguageContext language, size_t start_pos);
    
    // ç‰¹å®šè¯­è¨€çš„åˆ†å‰²é€»è¾‘
    size_t findCHTLSegmentEnd(size_t start_pos);
    size_t findCHTLJSSegmentEnd(size_t start_pos);
    size_t findCSSSegmentEnd(size_t start_pos);
    size_t findJSSegmentEnd(size_t start_pos);
};

std::vector<CodeSegment> CodeSegmenter::segmentCode(const std::string& source_code) {
    std::vector<CodeSegment> segments;
    token_stream_ = TokenStream(source_code);
    
    while (!token_stream_.isAtEnd()) {
        Token current_token = token_stream_.peek();
        
        // æ£€æµ‹è¯­è¨€ä¸Šä¸‹æ–‡
        LanguageContext detected_language = language_detector_.detectLanguage(
            token_stream_, token_stream_.getCurrentPosition());
        
        // å¦‚æœè¯­è¨€ä¸Šä¸‹æ–‡æ”¹å˜ï¼Œåˆ›å»ºæ–°æ®µ
        if (context_stack_.getCurrentContext() != detected_language) {
            if (!context_stack_.isInNestedContext()) {
                context_stack_.pushContext(detected_language, current_token.location);
            }
        }
        
        // ç¡®å®šæ®µç»“æŸä½ç½®
        size_t start_pos = token_stream_.getCurrentPosition();
        size_t end_pos = findSegmentEnd(detected_language, start_pos);
        
        // åˆ›å»ºä»£ç æ®µ
        CodeSegment segment = extractSegment(detected_language, start_pos, end_pos);
        segments.push_back(segment);
        
        // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªæ®µ
        token_stream_.setPosition(end_pos);
        context_stack_.popContext();
    }
    
    return segments;
}
```

#### 2. åµŒå¥—è¯­è¨€å¤„ç†
```cpp
size_t CodeSegmenter::findCHTLSegmentEnd(size_t start_pos) {
    size_t brace_count = 0;
    size_t current_pos = start_pos;
    bool in_string = false;
    char quote_char = '\0';
    
    while (current_pos < token_stream_.size()) {
        Token token = token_stream_.getToken(current_pos);
        
        // å¤„ç†å­—ç¬¦ä¸²
        if (!in_string && (token.type == TokenType::String)) {
            in_string = true;
            quote_char = token.text[0];
        } else if (in_string && token.text == std::string(1, quote_char)) {
            in_string = false;
            quote_char = '\0';
        }
        
        if (!in_string) {
            // æ£€æµ‹åµŒå¥—çš„scriptå—
            if (token.type == TokenType::Identifier && token.text == "script") {
                Token next_token = token_stream_.getToken(current_pos + 1);
                if (next_token.type == TokenType::LeftBrace) {
                    // è¿™æ˜¯ä¸€ä¸ªscriptå—ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
                    size_t script_end = findNestedScriptEnd(current_pos + 2);
                    current_pos = script_end;
                    continue;
                }
            }
            
            // å¤„ç†èŠ±æ‹¬å·
            if (token.type == TokenType::LeftBrace) {
                brace_count++;
            } else if (token.type == TokenType::RightBrace) {
                brace_count--;
                if (brace_count == 0) {
                    return current_pos + 1;  // åŒ…å«ç»“æŸèŠ±æ‹¬å·
                }
            }
        }
        
        current_pos++;
    }
    
    return current_pos;
}

size_t CodeSegmenter::findNestedScriptEnd(size_t start_pos) {
    size_t brace_count = 1;  // å·²ç»é‡åˆ°å¼€å§‹çš„èŠ±æ‹¬å·
    size_t current_pos = start_pos;
    
    while (current_pos < token_stream_.size() && brace_count > 0) {
        Token token = token_stream_.getToken(current_pos);
        
        if (token.type == TokenType::LeftBrace) {
            brace_count++;
        } else if (token.type == TokenType::RightBrace) {
            brace_count--;
        }
        
        current_pos++;
    }
    
    return current_pos;
}
```

## ç»Ÿä¸€æ‰«æå™¨å®ç°

### ğŸ”„ **ä¸»æ‰«ææµç¨‹**

```cpp
// src/Scanner/CHTLUnifiedScanner.h
class CHTLUnifiedScanner {
private:
    TokenStream token_stream_;
    ContextStack context_stack_;
    LanguageDetector language_detector_;
    CodeSegmenter code_segmenter_;
    
    // æ‰«æçŠ¶æ€
    ScannerState current_state_;
    std::unordered_map<std::string, std::string> scanner_options_;
    
public:
    CHTLUnifiedScanner();
    
    // ä¸»è¦æ¥å£
    ScanResult scan(const std::string& source_code);
    ScanResult scanFile(const std::string& file_path);
    
    // é…ç½®æ¥å£
    void setOption(const std::string& key, const std::string& value);
    void enableDebugMode(bool enable);
    void setLanguagePriority(const std::vector<LanguageContext>& priority);
    
private:
    // å†…éƒ¨æ‰«ææ–¹æ³•
    void preprocessSource(std::string& source);
    void initializeDetectionPatterns();
    void validateSegments(const std::vector<CodeSegment>& segments);
    
    // ä¼˜åŒ–æ–¹æ³•
    void optimizeSegments(std::vector<CodeSegment>& segments);
    void mergeAdjacentSegments(std::vector<CodeSegment>& segments);
    void resolveAmbiguousSegments(std::vector<CodeSegment>& segments);
};

struct ScanResult {
    bool success;
    std::vector<CodeSegment> segments;
    std::vector<ScanError> errors;
    std::vector<ScanWarning> warnings;
    ScanStatistics statistics;
};

ScanResult CHTLUnifiedScanner::scan(const std::string& source_code) {
    ScanResult result;
    
    try {
        // 1. é¢„å¤„ç†æºä»£ç 
        std::string processed_source = source_code;
        preprocessSource(processed_source);
        
        // 2. åˆå§‹åŒ–ä»¤ç‰Œæµ
        token_stream_ = TokenStream(processed_source);
        
        // 3. åˆ†å‰²ä»£ç 
        result.segments = code_segmenter_.segmentCode(processed_source);
        
        // 4. éªŒè¯åˆ†å‰²ç»“æœ
        validateSegments(result.segments);
        
        // 5. ä¼˜åŒ–åˆ†å‰²ç»“æœ
        optimizeSegments(result.segments);
        
        // 6. ç”Ÿæˆç»Ÿè®¡ä¿¡æ¯
        result.statistics = generateStatistics(result.segments);
        
        result.success = true;
        
    } catch (const ScanException& e) {
        result.success = false;
        result.errors.push_back(ScanError{e.what(), e.getLocation()});
    }
    
    return result;
}
```

### ğŸ“Š **æ€§èƒ½ä¼˜åŒ–**

#### 1. é¢„ç¼–è¯‘æ¨¡å¼è¯†åˆ«
```cpp
class PatternCache {
private:
    std::unordered_map<std::string, LanguageContext> keyword_cache_;
    std::unordered_map<std::string, DetectionResult> pattern_cache_;
    
public:
    void precompilePatterns() {
        // é¢„ç¼–è¯‘å¸¸ç”¨æ¨¡å¼
        for (const auto& keyword : common_keywords) {
            keyword_cache_[keyword] = detectLanguageFromKeyword(keyword);
        }
    }
    
    LanguageContext getCachedLanguage(const std::string& keyword) {
        auto it = keyword_cache_.find(keyword);
        return (it != keyword_cache_.end()) ? it->second : LanguageContext::JavaScript;
    }
};
```

#### 2. å¹¶è¡Œæ‰«æ
```cpp
class ParallelScanner {
public:
    ScanResult parallelScan(const std::string& source_code, size_t thread_count = 4) {
        // å°†æºä»£ç åˆ†å—
        std::vector<std::string> chunks = divideIntoChunks(source_code, thread_count);
        
        // å¹¶è¡Œæ‰«ææ¯ä¸ªå—
        std::vector<std::future<std::vector<CodeSegment>>> futures;
        for (const auto& chunk : chunks) {
            futures.push_back(std::async(std::launch::async, [this, chunk] {
                return code_segmenter_.segmentCode(chunk);
            }));
        }
        
        // åˆå¹¶ç»“æœ
        ScanResult result;
        for (auto& future : futures) {
            auto segments = future.get();
            result.segments.insert(result.segments.end(), segments.begin(), segments.end());
        }
        
        // åˆå¹¶è¾¹ç•Œå¤„çš„æ®µ
        mergeBoundarySegments(result.segments);
        
        return result;
    }
};
```

#### 3. å†…å­˜æ± ä¼˜åŒ–
```cpp
class TokenPool {
private:
    std::vector<Token> token_pool_;
    size_t next_available_;
    
public:
    Token* allocateToken() {
        if (next_available_ >= token_pool_.size()) {
            token_pool_.resize(token_pool_.size() * 2);
        }
        return &token_pool_[next_available_++];
    }
    
    void reset() {
        next_available_ = 0;
    }
};
```

## é”™è¯¯å¤„ç†å’Œè°ƒè¯•

### ğŸ› **é”™è¯¯ç±»å‹**

```cpp
enum class ScanErrorType {
    UnterminatedString,     // æœªç»ˆç»“çš„å­—ç¬¦ä¸²
    UnterminatedComment,    // æœªç»ˆç»“çš„æ³¨é‡Š
    UnbalancedBraces,       // ä¸å¹³è¡¡çš„èŠ±æ‹¬å·
    AmbiguousLanguage,      // è¯­è¨€æ£€æµ‹æ¨¡ç³Š
    InvalidCharacter,       // æ— æ•ˆå­—ç¬¦
    ContextMismatch,        // ä¸Šä¸‹æ–‡ä¸åŒ¹é…
    SegmentationError       // åˆ†å‰²é”™è¯¯
};

class ScanError {
public:
    ScanErrorType type;
    std::string message;
    SourceLocation location;
    std::string suggestion;
    
    std::string format() const {
        return formatScanError(type, message, location, suggestion);
    }
};
```

### ğŸ” **è°ƒè¯•å·¥å…·**

```cpp
class ScannerDebugger {
private:
    bool debug_enabled_;
    std::ofstream debug_log_;
    
public:
    void enableDebug(const std::string& log_file) {
        debug_enabled_ = true;
        debug_log_.open(log_file);
    }
    
    void logTokenStream(const TokenStream& stream) {
        if (!debug_enabled_) return;
        
        debug_log_ << "=== Token Stream ===" << std::endl;
        for (size_t i = 0; i < stream.size(); ++i) {
            Token token = stream.getToken(i);
            debug_log_ << i << ": " << tokenTypeToString(token.type) 
                      << " \"" << token.text << "\" @" 
                      << token.location.line << ":" << token.location.column << std::endl;
        }
    }
    
    void logContextStack(const ContextStack& stack) {
        if (!debug_enabled_) return;
        
        debug_log_ << "=== Context Stack ===" << std::endl;
        auto contexts = stack.getContextChain();
        for (size_t i = 0; i < contexts.size(); ++i) {
            debug_log_ << i << ": " << languageContextToString(contexts[i]) << std::endl;
        }
    }
    
    void logSegments(const std::vector<CodeSegment>& segments) {
        if (!debug_enabled_) return;
        
        debug_log_ << "=== Code Segments ===" << std::endl;
        for (size_t i = 0; i < segments.size(); ++i) {
            const auto& segment = segments[i];
            debug_log_ << "Segment " << i << ": " 
                      << languageContextToString(segment.language) << std::endl;
            debug_log_ << "Content: " << segment.content.substr(0, 100) 
                      << (segment.content.length() > 100 ? "..." : "") << std::endl;
            debug_log_ << "Location: " << segment.start_location.line 
                      << ":" << segment.start_location.column << " - "
                      << segment.end_location.line << ":" << segment.end_location.column << std::endl;
            debug_log_ << "---" << std::endl;
        }
    }
};
```

## æ‰©å±•æ€§è®¾è®¡

### ğŸ”Œ **æ’ä»¶æ¥å£**

```cpp
// è¯­è¨€æ£€æµ‹æ’ä»¶æ¥å£
class LanguageDetectorPlugin {
public:
    virtual ~LanguageDetectorPlugin() = default;
    
    virtual std::string getName() const = 0;
    virtual std::vector<std::string> getSupportedLanguages() const = 0;
    virtual DetectionResult detectLanguage(const std::string& code) const = 0;
    virtual void initialize(const PluginConfig& config) = 0;
};

// ä»£ç åˆ†å‰²æ’ä»¶æ¥å£
class CodeSegmenterPlugin {
public:
    virtual ~CodeSegmenterPlugin() = default;
    
    virtual std::string getName() const = 0;
    virtual bool canHandle(LanguageContext language) const = 0;
    virtual size_t findSegmentEnd(const TokenStream& stream, size_t start_pos) const = 0;
};

// æ’ä»¶ç®¡ç†å™¨
class PluginManager {
private:
    std::vector<std::unique_ptr<LanguageDetectorPlugin>> detector_plugins_;
    std::vector<std::unique_ptr<CodeSegmenterPlugin>> segmenter_plugins_;
    
public:
    void registerDetectorPlugin(std::unique_ptr<LanguageDetectorPlugin> plugin);
    void registerSegmenterPlugin(std::unique_ptr<CodeSegmenterPlugin> plugin);
    
    DetectionResult detectWithPlugins(const std::string& code);
    size_t segmentWithPlugins(const TokenStream& stream, LanguageContext language, size_t start_pos);
};
```

### ğŸ¯ **è‡ªå®šä¹‰è¯­è¨€æ”¯æŒ**

```cpp
// ç”¨æˆ·å¯ä»¥é€šè¿‡é…ç½®æ–‡ä»¶æ·»åŠ æ–°è¯­è¨€æ”¯æŒ
class CustomLanguageConfig {
public:
    struct LanguageDefinition {
        std::string name;
        LanguageContext context;
        std::vector<std::string> keywords;
        std::vector<std::regex> patterns;
        std::string comment_start;
        std::string comment_end;
        char string_delimiter;
        char escape_character;
    };
    
    void loadFromFile(const std::string& config_file);
    void addLanguageDefinition(const LanguageDefinition& definition);
    std::vector<LanguageDefinition> getAllDefinitions() const;
};
```

## ä½¿ç”¨ç¤ºä¾‹

### ğŸ“ **åŸºæœ¬ä½¿ç”¨**

```cpp
#include "Scanner/CHTLUnifiedScanner.h"

int main() {
    CHTLUnifiedScanner scanner;
    
    // å¯ç”¨è°ƒè¯•æ¨¡å¼
    scanner.enableDebugMode(true);
    
    // è®¾ç½®è¯­è¨€ä¼˜å…ˆçº§
    scanner.setLanguagePriority({
        LanguageContext::CHTL,
        LanguageContext::CHTL_JS,
        LanguageContext::CSS,
        LanguageContext::JavaScript
    });
    
    // æ‰«ææºä»£ç 
    std::string source_code = R"(
        div.container {
            h1 { "Hello CHTL" }
            
            script {
                listen buttonHandler = {
                    click: () => {
                        console.log('Button clicked');
                    }
                };
                
                {{.btn}} &-> click {
                    buttonHandler->click();
                };
            }
            
            style {
                .container {
                    max-width: 1200px;
                    margin: 0 auto;
                }
                
                .btn {
                    background: #007bff;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 4px;
                }
            }
        }
    )";
    
    ScanResult result = scanner.scan(source_code);
    
    if (result.success) {
        std::cout << "æ‰«ææˆåŠŸï¼æ‰¾åˆ° " << result.segments.size() << " ä¸ªä»£ç æ®µï¼š" << std::endl;
        
        for (const auto& segment : result.segments) {
            std::cout << "è¯­è¨€: " << languageContextToString(segment.language) << std::endl;
            std::cout << "ä½ç½®: " << segment.start_location.line << ":" 
                      << segment.start_location.column << " - "
                      << segment.end_location.line << ":" 
                      << segment.end_location.column << std::endl;
            std::cout << "å†…å®¹é¢„è§ˆ: " << segment.content.substr(0, 50) << "..." << std::endl;
            std::cout << "---" << std::endl;
        }
        
        // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
        std::cout << "ç»Ÿè®¡ä¿¡æ¯:" << std::endl;
        std::cout << "CHTLæ®µæ•°: " << result.statistics.chtl_segments << std::endl;
        std::cout << "CHTL JSæ®µæ•°: " << result.statistics.chtljs_segments << std::endl;
        std::cout << "CSSæ®µæ•°: " << result.statistics.css_segments << std::endl;
        std::cout << "JSæ®µæ•°: " << result.statistics.js_segments << std::endl;
        
    } else {
        std::cout << "æ‰«æå¤±è´¥ï¼š" << std::endl;
        for (const auto& error : result.errors) {
            std::cout << "é”™è¯¯: " << error.format() << std::endl;
        }
    }
    
    return 0;
}
```

---

ç»Ÿä¸€æ‰«æå™¨æ˜¯CHTLç¼–è¯‘å™¨ç³»ç»Ÿçš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ï¼Œå®ƒçš„å‡†ç¡®æ€§å’Œæ€§èƒ½ç›´æ¥å½±å“åˆ°æ•´ä¸ªç¼–è¯‘è¿‡ç¨‹çš„è´¨é‡ã€‚é€šè¿‡ç²¾å¿ƒè®¾è®¡çš„è¯­è¨€æ£€æµ‹ç®—æ³•å’Œä¸Šä¸‹æ–‡ç®¡ç†æœºåˆ¶ï¼Œç»Ÿä¸€æ‰«æå™¨èƒ½å¤Ÿå‡†ç¡®åœ°å¤„ç†å¤æ‚çš„æ··åˆè¯­è¨€ä»£ç ï¼Œä¸ºåç»­çš„ç¼–è¯‘é˜¶æ®µæä¾›å¯é çš„è¾“å…¥ã€‚
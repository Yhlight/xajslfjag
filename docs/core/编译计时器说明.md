# 编译计时器说明

## 概述

编译计时器是CHTL项目的重要调试和性能监控工具，位于`src/Test/CompileTimer/`目录。它提供精确的编译时间测量、内存使用监控、性能瓶颈检测和无限循环保护等功能，确保编译器在各种条件下都能稳定高效运行。

## 核心功能

### ⏱️ **时间测量**

编译计时器能够精确测量编译过程中各个阶段的耗时：

- **词法分析时间**: Token化过程耗时
- **语法分析时间**: AST构建耗时
- **语义分析时间**: 类型检查和语义验证耗时
- **代码生成时间**: 目标代码生成耗时
- **总编译时间**: 端到端编译时间

### 📊 **内存监控**

实时监控编译过程中的内存使用情况：

- **峰值内存使用**: 编译过程中的最大内存占用
- **内存增长趋势**: 检测内存泄漏和异常增长
- **各阶段内存分布**: 了解哪个阶段消耗内存最多
- **内存回收效率**: 监控垃圾回收和资源释放

### 🛡️ **无限循环保护**

提供多层次的无限循环检测和保护机制：

- **时间阈值保护**: 超过预设时间自动终止
- **递归深度检测**: 防止栈溢出
- **进度监控**: 检测编译进度停滞
- **资源耗尽检测**: 内存或CPU使用过度时告警

## 架构设计

### 🏗️ **类结构图**

```cpp
// src/Test/CompileTimer/CompileTimer.h

class CompileTimer {
public:
    // 主要接口
    static CompileTimer& getInstance();
    
    void startPhase(const std::string& phase_name);
    void endPhase(const std::string& phase_name);
    void recordEvent(const std::string& event_name, const std::string& details = "");
    
    // 保护机制
    void setTimeoutLimit(std::chrono::seconds timeout);
    void setMemoryLimit(size_t max_memory_mb);
    void enableInfiniteLoopDetection(bool enable);
    
    // 报告生成
    TimingReport generateReport() const;
    void exportReport(const std::string& filename, ReportFormat format) const;
    
private:
    CompileTimer() = default;
    
    // 内部状态
    std::unordered_map<std::string, PhaseInfo> phases_;
    std::vector<TimingEvent> events_;
    std::chrono::high_resolution_clock::time_point start_time_;
    
    // 保护机制
    SafetyMonitor safety_monitor_;
    MemoryTracker memory_tracker_;
    ProgressWatchdog progress_watchdog_;
};
```

### 🧩 **核心组件**

#### 1. PhaseInfo (阶段信息)
```cpp
struct PhaseInfo {
    std::string name;
    std::chrono::high_resolution_clock::time_point start_time;
    std::chrono::high_resolution_clock::time_point end_time;
    std::chrono::milliseconds duration;
    size_t memory_start;
    size_t memory_peak;
    size_t memory_end;
    std::vector<std::string> sub_phases;
    bool completed;
    
    // 统计信息
    size_t token_count;
    size_t ast_node_count;
    size_t error_count;
    size_t warning_count;
};
```

#### 2. SafetyMonitor (安全监控器)
```cpp
class SafetyMonitor {
private:
    std::chrono::seconds timeout_limit_;
    size_t memory_limit_mb_;
    bool infinite_loop_detection_enabled_;
    std::thread watchdog_thread_;
    std::atomic<bool> should_stop_;
    
public:
    SafetyMonitor();
    ~SafetyMonitor();
    
    void startMonitoring();
    void stopMonitoring();
    
    void setTimeoutLimit(std::chrono::seconds timeout);
    void setMemoryLimit(size_t max_memory_mb);
    void enableInfiniteLoopDetection(bool enable);
    
    // 检查方法
    bool isTimeoutExceeded() const;
    bool isMemoryLimitExceeded() const;
    bool isInfiniteLoopDetected() const;
    
    // 强制终止
    void forceTermination(const std::string& reason);
    
private:
    void watchdogLoop();
    void checkProgress();
    void analyzeCallStack();
    bool detectSuspiciousPatterns();
};
```

#### 3. MemoryTracker (内存追踪器)
```cpp
class MemoryTracker {
private:
    size_t initial_memory_;
    size_t peak_memory_;
    size_t current_memory_;
    std::vector<MemorySnapshot> snapshots_;
    std::chrono::steady_clock::time_point last_check_;
    
public:
    void startTracking();
    void takeSnapshot(const std::string& label);
    void stopTracking();
    
    size_t getCurrentMemoryUsage() const;
    size_t getPeakMemoryUsage() const;
    size_t getMemoryDelta() const;
    
    std::vector<MemorySnapshot> getSnapshots() const;
    MemoryReport generateMemoryReport() const;
    
private:
    size_t getSystemMemoryUsage() const;
    void updateMemoryStats();
    
    struct MemorySnapshot {
        std::string label;
        std::chrono::steady_clock::time_point timestamp;
        size_t memory_usage;
        size_t heap_size;
        size_t stack_size;
    };
};
```

#### 4. ProgressWatchdog (进度监控器)
```cpp
class ProgressWatchdog {
private:
    std::chrono::steady_clock::time_point last_progress_time_;
    std::chrono::seconds stall_threshold_;
    size_t last_processed_tokens_;
    size_t last_ast_nodes_;
    bool is_monitoring_;
    
public:
    void startWatching();
    void reportProgress(size_t tokens_processed, size_t ast_nodes_created);
    void stopWatching();
    
    bool isProgressStalled() const;
    std::chrono::milliseconds getTimeSinceLastProgress() const;
    
    void setStallThreshold(std::chrono::seconds threshold);
    
private:
    bool hasProgressOccurred(size_t tokens, size_t nodes) const;
    void updateProgressTime();
};
```

## 使用方法

### 🚀 **基本使用**

```cpp
// 在编译器主函数中启用计时器
int main(int argc, char* argv[]) {
    auto& timer = CompileTimer::getInstance();
    
    // 配置安全限制
    timer.setTimeoutLimit(std::chrono::seconds(300));  // 5分钟超时
    timer.setMemoryLimit(1024);                         // 1GB内存限制
    timer.enableInfiniteLoopDetection(true);
    
    try {
        // 开始编译
        timer.startPhase("Total_Compilation");
        
        CHTLCompiler compiler(argv[1]);
        auto result = compiler.compile();
        
        timer.endPhase("Total_Compilation");
        
        // 生成报告
        auto report = timer.generateReport();
        timer.exportReport("compilation_report.json", ReportFormat::JSON);
        
        std::cout << "编译完成！耗时: " << report.total_time.count() << "ms" << std::endl;
        std::cout << "峰值内存: " << report.peak_memory_mb << "MB" << std::endl;
        
    } catch (const CompilationTimeoutException& e) {
        std::cerr << "编译超时: " << e.what() << std::endl;
        return 1;
    } catch (const MemoryLimitException& e) {
        std::cerr << "内存限制超出: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```

### 🔍 **详细阶段监控**

```cpp
// 在编译器各个阶段使用计时器
class CHTLCompiler {
public:
    CompilationResult compile(const std::string& source_code) {
        auto& timer = CompileTimer::getInstance();
        
        // 词法分析阶段
        timer.startPhase("Lexical_Analysis");
        auto tokens = lexer_.tokenize(source_code);
        timer.recordEvent("Tokens_Generated", "Count: " + std::to_string(tokens.size()));
        timer.endPhase("Lexical_Analysis");
        
        // 语法分析阶段
        timer.startPhase("Syntax_Analysis");
        auto ast = parser_.parse(tokens);
        timer.recordEvent("AST_Nodes_Created", "Count: " + std::to_string(ast->getNodeCount()));
        timer.endPhase("Syntax_Analysis");
        
        // 语义分析阶段
        timer.startPhase("Semantic_Analysis");
        semantic_analyzer_.analyze(ast.get());
        timer.endPhase("Semantic_Analysis");
        
        // 代码生成阶段
        timer.startPhase("Code_Generation");
        auto result = code_generator_.generate(ast.get());
        timer.recordEvent("Code_Generated", "Size: " + std::to_string(result.size()));
        timer.endPhase("Code_Generation");
        
        return result;
    }
};
```

### 📊 **性能分析**

```cpp
// 自动性能分析
class PerformanceAnalyzer {
public:
    static void analyzeCompilationPerformance(const TimingReport& report) {
        std::cout << "\n=== CHTL编译性能分析 ===" << std::endl;
        
        // 总体性能
        std::cout << "总编译时间: " << report.total_time.count() << "ms" << std::endl;
        std::cout << "峰值内存使用: " << report.peak_memory_mb << "MB" << std::endl;
        
        // 各阶段性能分析
        for (const auto& [phase_name, phase_info] : report.phases) {
            double percentage = (double)phase_info.duration.count() / report.total_time.count() * 100.0;
            std::cout << "- " << phase_name << ": " 
                      << phase_info.duration.count() << "ms (" 
                      << std::fixed << std::setprecision(1) << percentage << "%)" << std::endl;
            
            // 性能建议
            if (percentage > 40.0) {
                std::cout << "  ⚠️  警告: " << phase_name << "占用时间过长，建议优化" << std::endl;
            }
        }
        
        // 内存效率分析
        if (report.peak_memory_mb > 500) {
            std::cout << "⚠️  内存使用较高，建议检查内存泄漏" << std::endl;
        }
        
        // 吞吐量分析
        if (report.tokens_per_second < 10000) {
            std::cout << "⚠️  Token处理速度较慢，建议优化词法分析器" << std::endl;
        }
    }
};
```

## 保护机制详解

### ⏰ **超时保护**

```cpp
class TimeoutProtection {
private:
    std::chrono::seconds timeout_limit_;
    std::chrono::steady_clock::time_point start_time_;
    std::atomic<bool> timeout_triggered_;
    
public:
    void startTimeout(std::chrono::seconds limit) {
        timeout_limit_ = limit;
        start_time_ = std::chrono::steady_clock::now();
        timeout_triggered_ = false;
        
        // 启动监控线程
        std::thread([this]() {
            std::this_thread::sleep_for(timeout_limit_);
            if (!timeout_triggered_) {
                triggerTimeout();
            }
        }).detach();
    }
    
    void checkTimeout() {
        auto current_time = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
            current_time - start_time_);
        
        if (elapsed >= timeout_limit_) {
            throw CompilationTimeoutException(
                "编译超时: 超过" + std::to_string(timeout_limit_.count()) + "秒");
        }
    }
    
private:
    void triggerTimeout() {
        timeout_triggered_ = true;
        // 设置全局标志，通知编译器停止
        CompileTimer::getInstance().forceStop("Timeout exceeded");
    }
};
```

### 🧠 **内存监控**

```cpp
class MemoryMonitor {
private:
    size_t memory_limit_bytes_;
    std::atomic<size_t> current_memory_;
    std::thread monitor_thread_;
    std::atomic<bool> monitoring_;
    
public:
    void startMonitoring(size_t limit_mb) {
        memory_limit_bytes_ = limit_mb * 1024 * 1024;
        monitoring_ = true;
        
        monitor_thread_ = std::thread([this]() {
            while (monitoring_) {
                updateMemoryUsage();
                checkMemoryLimit();
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        });
    }
    
    void stopMonitoring() {
        monitoring_ = false;
        if (monitor_thread_.joinable()) {
            monitor_thread_.join();
        }
    }
    
private:
    void updateMemoryUsage() {
        // 获取当前进程内存使用
        #ifdef _WIN32
            PROCESS_MEMORY_COUNTERS pmc;
            GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));
            current_memory_ = pmc.WorkingSetSize;
        #elif defined(__linux__)
            std::ifstream status("/proc/self/status");
            std::string line;
            while (std::getline(status, line)) {
                if (line.substr(0, 6) == "VmRSS:") {
                    size_t memory_kb = std::stoul(line.substr(7));
                    current_memory_ = memory_kb * 1024;
                    break;
                }
            }
        #elif defined(__APPLE__)
            struct mach_task_basic_info info;
            mach_msg_type_number_t size = MACH_TASK_BASIC_INFO_COUNT;
            kern_return_t kerr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO,
                                         (task_info_t)&info, &size);
            if (kerr == KERN_SUCCESS) {
                current_memory_ = info.resident_size;
            }
        #endif
    }
    
    void checkMemoryLimit() {
        if (current_memory_ > memory_limit_bytes_) {
            throw MemoryLimitException(
                "内存使用超限: " + std::to_string(current_memory_ / 1024 / 1024) + 
                "MB > " + std::to_string(memory_limit_bytes_ / 1024 / 1024) + "MB");
        }
    }
};
```

### 🔄 **无限循环检测**

```cpp
class InfiniteLoopDetector {
private:
    struct CallSiteInfo {
        std::string function_name;
        std::string file_name;
        int line_number;
        size_t call_count;
        std::chrono::steady_clock::time_point last_call;
    };
    
    std::unordered_map<std::string, CallSiteInfo> call_sites_;
    size_t max_call_count_;
    std::chrono::milliseconds max_call_frequency_;
    
public:
    InfiniteLoopDetector() 
        : max_call_count_(10000)
        , max_call_frequency_(std::chrono::milliseconds(1)) {
    }
    
    void recordCall(const std::string& function_name, 
                   const std::string& file_name, 
                   int line_number) {
        std::string call_site = function_name + "@" + file_name + ":" + 
                               std::to_string(line_number);
        
        auto now = std::chrono::steady_clock::now();
        auto& info = call_sites_[call_site];
        
        info.function_name = function_name;
        info.file_name = file_name;
        info.line_number = line_number;
        info.call_count++;
        
        // 检测调用频率
        if (info.last_call != std::chrono::steady_clock::time_point{}) {
            auto frequency = now - info.last_call;
            if (frequency < max_call_frequency_ && info.call_count > 100) {
                throw InfiniteLoopException(
                    "检测到可能的无限循环在 " + function_name + 
                    " (" + file_name + ":" + std::to_string(line_number) + ")");
            }
        }
        
        info.last_call = now;
        
        // 检测调用次数
        if (info.call_count > max_call_count_) {
            throw InfiniteLoopException(
                "函数调用次数过多: " + function_name + 
                " 已调用 " + std::to_string(info.call_count) + " 次");
        }
    }
    
    void resetCounters() {
        call_sites_.clear();
    }
    
    std::vector<CallSiteInfo> getSuspiciousCallSites() const {
        std::vector<CallSiteInfo> suspicious;
        for (const auto& [_, info] : call_sites_) {
            if (info.call_count > max_call_count_ / 10) {
                suspicious.push_back(info);
            }
        }
        return suspicious;
    }
};

// 宏定义，方便在代码中插入检测点
#define CHTL_LOOP_CHECK() \
    CompileTimer::getInstance().recordLoopIteration(__FUNCTION__, __FILE__, __LINE__)
```

## 报告生成

### 📊 **报告格式**

#### JSON格式报告
```json
{
    "compilation_summary": {
        "total_time_ms": 1234,
        "peak_memory_mb": 156,
        "success": true,
        "compiler_version": "1.0.0",
        "timestamp": "2024-01-15T10:30:00Z"
    },
    "phases": {
        "Lexical_Analysis": {
            "duration_ms": 45,
            "memory_start_mb": 12,
            "memory_peak_mb": 25,
            "memory_end_mb": 20,
            "tokens_generated": 1543,
            "errors": 0,
            "warnings": 2
        },
        "Syntax_Analysis": {
            "duration_ms": 234,
            "memory_start_mb": 20,
            "memory_peak_mb": 67,
            "memory_end_mb": 45,
            "ast_nodes_created": 892,
            "errors": 0,
            "warnings": 1
        }
    },
    "events": [
        {
            "timestamp": "2024-01-15T10:30:01.123Z",
            "type": "phase_start",
            "phase": "Lexical_Analysis"
        },
        {
            "timestamp": "2024-01-15T10:30:01.168Z",
            "type": "phase_end",
            "phase": "Lexical_Analysis"
        }
    ],
    "performance_metrics": {
        "tokens_per_second": 34284,
        "ast_nodes_per_second": 3812,
        "memory_efficiency": 0.85,
        "cpu_utilization": 0.67
    },
    "safety_info": {
        "timeout_enabled": true,
        "timeout_limit_seconds": 300,
        "memory_limit_mb": 1024,
        "infinite_loop_detection": true,
        "violations": []
    }
}
```

#### HTML格式报告
```html
<!DOCTYPE html>
<html>
<head>
    <title>CHTL编译性能报告</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .metric { margin: 10px; padding: 10px; border: 1px solid #ccc; }
        .phase-chart { width: 600px; height: 400px; }
        .memory-chart { width: 800px; height: 300px; }
    </style>
</head>
<body>
    <h1>CHTL编译性能报告</h1>
    
    <div class="summary">
        <div class="metric">
            <h3>总编译时间</h3>
            <p>1.234 秒</p>
        </div>
        <div class="metric">
            <h3>峰值内存</h3>
            <p>156 MB</p>
        </div>
    </div>
    
    <div class="charts">
        <canvas id="phaseChart" class="phase-chart"></canvas>
        <canvas id="memoryChart" class="memory-chart"></canvas>
    </div>
    
    <script>
        // 阶段时间分布图
        const phaseCtx = document.getElementById('phaseChart').getContext('2d');
        new Chart(phaseCtx, {
            type: 'pie',
            data: {
                labels: ['词法分析', '语法分析', '语义分析', '代码生成'],
                datasets: [{
                    data: [45, 234, 156, 89],
                    backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0']
                }]
            }
        });
        
        // 内存使用趋势图
        const memoryCtx = document.getElementById('memoryChart').getContext('2d');
        new Chart(memoryCtx, {
            type: 'line',
            data: {
                labels: ['开始', '词法分析', '语法分析', '语义分析', '代码生成', '完成'],
                datasets: [{
                    label: '内存使用 (MB)',
                    data: [12, 25, 67, 89, 134, 45],
                    borderColor: '#36A2EB',
                    fill: false
                }]
            }
        });
    </script>
</body>
</html>
```

### 📈 **性能趋势分析**

```cpp
class PerformanceTrendAnalyzer {
private:
    std::vector<TimingReport> historical_reports_;
    
public:
    void addReport(const TimingReport& report) {
        historical_reports_.push_back(report);
        
        // 保持最近100次编译记录
        if (historical_reports_.size() > 100) {
            historical_reports_.erase(historical_reports_.begin());
        }
    }
    
    TrendAnalysis analyzeTrends() const {
        TrendAnalysis analysis;
        
        if (historical_reports_.size() < 2) {
            return analysis;
        }
        
        // 计算平均值和趋势
        double total_time_sum = 0;
        double memory_sum = 0;
        
        for (const auto& report : historical_reports_) {
            total_time_sum += report.total_time.count();
            memory_sum += report.peak_memory_mb;
        }
        
        analysis.average_compile_time = total_time_sum / historical_reports_.size();
        analysis.average_memory_usage = memory_sum / historical_reports_.size();
        
        // 检测性能回归
        auto recent_avg = calculateRecentAverage(10);  // 最近10次
        auto baseline_avg = calculateBaselineAverage(); // 基准平均值
        
        if (recent_avg.compile_time > baseline_avg.compile_time * 1.2) {
            analysis.performance_regression = true;
            analysis.regression_details = "编译时间增加了 " + 
                std::to_string((recent_avg.compile_time / baseline_avg.compile_time - 1) * 100) + "%";
        }
        
        return analysis;
    }
    
    struct TrendAnalysis {
        double average_compile_time;
        double average_memory_usage;
        bool performance_regression;
        std::string regression_details;
        std::vector<std::string> recommendations;
    };
};
```

## 配置和定制

### ⚙️ **配置文件**

```ini
# compile_timer_config.ini

[General]
enabled = true
debug_mode = false
report_format = json
report_file = compilation_report.json

[Safety]
timeout_limit_seconds = 300
memory_limit_mb = 1024
infinite_loop_detection = true
max_recursion_depth = 1000

[Monitoring]
memory_check_interval_ms = 100
progress_check_interval_ms = 1000
stall_threshold_seconds = 30

[Performance]
enable_trend_analysis = true
historical_report_count = 100
performance_regression_threshold = 1.2

[Alerts]
email_notifications = false
slack_webhook = ""
alert_threshold_time_ms = 10000
alert_threshold_memory_mb = 500
```

### 🎛️ **运行时配置**

```cpp
// 通过环境变量配置
void configureFromEnvironment() {
    auto& timer = CompileTimer::getInstance();
    
    // 从环境变量读取配置
    if (auto timeout = std::getenv("CHTL_COMPILE_TIMEOUT")) {
        timer.setTimeoutLimit(std::chrono::seconds(std::stoi(timeout)));
    }
    
    if (auto memory_limit = std::getenv("CHTL_MEMORY_LIMIT")) {
        timer.setMemoryLimit(std::stoi(memory_limit));
    }
    
    if (auto debug_mode = std::getenv("CHTL_DEBUG_TIMER")) {
        timer.enableDebugMode(std::string(debug_mode) == "true");
    }
}

// 通过命令行参数配置
void configureFromCommandLine(int argc, char* argv[]) {
    auto& timer = CompileTimer::getInstance();
    
    for (int i = 1; i < argc; i++) {
        std::string arg(argv[i]);
        
        if (arg == "--timeout" && i + 1 < argc) {
            timer.setTimeoutLimit(std::chrono::seconds(std::stoi(argv[++i])));
        } else if (arg == "--memory-limit" && i + 1 < argc) {
            timer.setMemoryLimit(std::stoi(argv[++i]));
        } else if (arg == "--enable-timer-debug") {
            timer.enableDebugMode(true);
        } else if (arg == "--disable-infinite-loop-detection") {
            timer.enableInfiniteLoopDetection(false);
        }
    }
}
```

## 最佳实践

### ✅ **使用建议**

1. **合理设置限制**
   ```cpp
   // 根据项目大小调整限制
   if (source_file_size > 1_MB) {
       timer.setTimeoutLimit(std::chrono::minutes(10));
       timer.setMemoryLimit(2048);  // 2GB
   } else {
       timer.setTimeoutLimit(std::chrono::minutes(2));
       timer.setMemoryLimit(512);   // 512MB
   }
   ```

2. **分阶段监控**
   ```cpp
   // 细粒度的阶段监控
   timer.startPhase("Lexical_Analysis");
   timer.startPhase("Token_Generation");
   // ... 具体操作
   timer.endPhase("Token_Generation");
   timer.endPhase("Lexical_Analysis");
   ```

3. **异常情况处理**
   ```cpp
   try {
       compile();
   } catch (const CompilationTimeoutException& e) {
       // 保存当前状态，便于调试
       timer.exportReport("timeout_debug.json", ReportFormat::JSON);
       logError("编译超时: " + std::string(e.what()));
   }
   ```

### 🚫 **避免的反模式**

```cpp
// ❌ 避免：过度细化的监控
timer.startPhase("SingleTokenProcessing");  // 过细
processToken();
timer.endPhase("SingleTokenProcessing");

// ✅ 推荐：合理的粒度
timer.startPhase("BatchTokenProcessing");
for (auto& token : tokens) {
    processToken(token);
}
timer.endPhase("BatchTokenProcessing");

// ❌ 避免：忘记结束阶段
timer.startPhase("Analysis");
performAnalysis();
// 忘记调用 timer.endPhase("Analysis");

// ✅ 推荐：使用RAII
class ScopedTimer {
public:
    ScopedTimer(const std::string& phase) : phase_(phase) {
        CompileTimer::getInstance().startPhase(phase_);
    }
    ~ScopedTimer() {
        CompileTimer::getInstance().endPhase(phase_);
    }
private:
    std::string phase_;
};
```

---

编译计时器是确保CHTL编译器稳定性和性能的重要工具。通过精确的时间测量、内存监控和安全保护机制，它为开发者提供了深入了解编译过程的能力，同时防止了潜在的无限循环和资源耗尽问题。
# ç¼–è¯‘è®¡æ—¶å™¨è¯´æ˜

## æ¦‚è¿°

ç¼–è¯‘è®¡æ—¶å™¨æ˜¯CHTLé¡¹ç›®çš„é‡è¦è°ƒè¯•å’Œæ€§èƒ½ç›‘æ§å·¥å…·ï¼Œä½äº`src/Test/CompileTimer/`ç›®å½•ã€‚å®ƒæä¾›ç²¾ç¡®çš„ç¼–è¯‘æ—¶é—´æµ‹é‡ã€å†…å­˜ä½¿ç”¨ç›‘æ§ã€æ€§èƒ½ç“¶é¢ˆæ£€æµ‹å’Œæ— é™å¾ªç¯ä¿æŠ¤ç­‰åŠŸèƒ½ï¼Œç¡®ä¿ç¼–è¯‘å™¨åœ¨å„ç§æ¡ä»¶ä¸‹éƒ½èƒ½ç¨³å®šé«˜æ•ˆè¿è¡Œã€‚

## æ ¸å¿ƒåŠŸèƒ½

### â±ï¸ **æ—¶é—´æµ‹é‡**

ç¼–è¯‘è®¡æ—¶å™¨èƒ½å¤Ÿç²¾ç¡®æµ‹é‡ç¼–è¯‘è¿‡ç¨‹ä¸­å„ä¸ªé˜¶æ®µçš„è€—æ—¶ï¼š

- **è¯æ³•åˆ†ææ—¶é—´**: TokenåŒ–è¿‡ç¨‹è€—æ—¶
- **è¯­æ³•åˆ†ææ—¶é—´**: ASTæ„å»ºè€—æ—¶
- **è¯­ä¹‰åˆ†ææ—¶é—´**: ç±»å‹æ£€æŸ¥å’Œè¯­ä¹‰éªŒè¯è€—æ—¶
- **ä»£ç ç”Ÿæˆæ—¶é—´**: ç›®æ ‡ä»£ç ç”Ÿæˆè€—æ—¶
- **æ€»ç¼–è¯‘æ—¶é—´**: ç«¯åˆ°ç«¯ç¼–è¯‘æ—¶é—´

### ğŸ“Š **å†…å­˜ç›‘æ§**

å®æ—¶ç›‘æ§ç¼–è¯‘è¿‡ç¨‹ä¸­çš„å†…å­˜ä½¿ç”¨æƒ…å†µï¼š

- **å³°å€¼å†…å­˜ä½¿ç”¨**: ç¼–è¯‘è¿‡ç¨‹ä¸­çš„æœ€å¤§å†…å­˜å ç”¨
- **å†…å­˜å¢é•¿è¶‹åŠ¿**: æ£€æµ‹å†…å­˜æ³„æ¼å’Œå¼‚å¸¸å¢é•¿
- **å„é˜¶æ®µå†…å­˜åˆ†å¸ƒ**: äº†è§£å“ªä¸ªé˜¶æ®µæ¶ˆè€—å†…å­˜æœ€å¤š
- **å†…å­˜å›æ”¶æ•ˆç‡**: ç›‘æ§åƒåœ¾å›æ”¶å’Œèµ„æºé‡Šæ”¾

### ğŸ›¡ï¸ **æ— é™å¾ªç¯ä¿æŠ¤**

æä¾›å¤šå±‚æ¬¡çš„æ— é™å¾ªç¯æ£€æµ‹å’Œä¿æŠ¤æœºåˆ¶ï¼š

- **æ—¶é—´é˜ˆå€¼ä¿æŠ¤**: è¶…è¿‡é¢„è®¾æ—¶é—´è‡ªåŠ¨ç»ˆæ­¢
- **é€’å½’æ·±åº¦æ£€æµ‹**: é˜²æ­¢æ ˆæº¢å‡º
- **è¿›åº¦ç›‘æ§**: æ£€æµ‹ç¼–è¯‘è¿›åº¦åœæ»
- **èµ„æºè€—å°½æ£€æµ‹**: å†…å­˜æˆ–CPUä½¿ç”¨è¿‡åº¦æ—¶å‘Šè­¦

## æ¶æ„è®¾è®¡

### ğŸ—ï¸ **ç±»ç»“æ„å›¾**

```cpp
// src/Test/CompileTimer/CompileTimer.h

class CompileTimer {
public:
    // ä¸»è¦æ¥å£
    static CompileTimer& getInstance();
    
    void startPhase(const std::string& phase_name);
    void endPhase(const std::string& phase_name);
    void recordEvent(const std::string& event_name, const std::string& details = "");
    
    // ä¿æŠ¤æœºåˆ¶
    void setTimeoutLimit(std::chrono::seconds timeout);
    void setMemoryLimit(size_t max_memory_mb);
    void enableInfiniteLoopDetection(bool enable);
    
    // æŠ¥å‘Šç”Ÿæˆ
    TimingReport generateReport() const;
    void exportReport(const std::string& filename, ReportFormat format) const;
    
private:
    CompileTimer() = default;
    
    // å†…éƒ¨çŠ¶æ€
    std::unordered_map<std::string, PhaseInfo> phases_;
    std::vector<TimingEvent> events_;
    std::chrono::high_resolution_clock::time_point start_time_;
    
    // ä¿æŠ¤æœºåˆ¶
    SafetyMonitor safety_monitor_;
    MemoryTracker memory_tracker_;
    ProgressWatchdog progress_watchdog_;
};
```

### ğŸ§© **æ ¸å¿ƒç»„ä»¶**

#### 1. PhaseInfo (é˜¶æ®µä¿¡æ¯)
```cpp
struct PhaseInfo {
    std::string name;
    std::chrono::high_resolution_clock::time_point start_time;
    std::chrono::high_resolution_clock::time_point end_time;
    std::chrono::milliseconds duration;
    size_t memory_start;
    size_t memory_peak;
    size_t memory_end;
    std::vector<std::string> sub_phases;
    bool completed;
    
    // ç»Ÿè®¡ä¿¡æ¯
    size_t token_count;
    size_t ast_node_count;
    size_t error_count;
    size_t warning_count;
};
```

#### 2. SafetyMonitor (å®‰å…¨ç›‘æ§å™¨)
```cpp
class SafetyMonitor {
private:
    std::chrono::seconds timeout_limit_;
    size_t memory_limit_mb_;
    bool infinite_loop_detection_enabled_;
    std::thread watchdog_thread_;
    std::atomic<bool> should_stop_;
    
public:
    SafetyMonitor();
    ~SafetyMonitor();
    
    void startMonitoring();
    void stopMonitoring();
    
    void setTimeoutLimit(std::chrono::seconds timeout);
    void setMemoryLimit(size_t max_memory_mb);
    void enableInfiniteLoopDetection(bool enable);
    
    // æ£€æŸ¥æ–¹æ³•
    bool isTimeoutExceeded() const;
    bool isMemoryLimitExceeded() const;
    bool isInfiniteLoopDetected() const;
    
    // å¼ºåˆ¶ç»ˆæ­¢
    void forceTermination(const std::string& reason);
    
private:
    void watchdogLoop();
    void checkProgress();
    void analyzeCallStack();
    bool detectSuspiciousPatterns();
};
```

#### 3. MemoryTracker (å†…å­˜è¿½è¸ªå™¨)
```cpp
class MemoryTracker {
private:
    size_t initial_memory_;
    size_t peak_memory_;
    size_t current_memory_;
    std::vector<MemorySnapshot> snapshots_;
    std::chrono::steady_clock::time_point last_check_;
    
public:
    void startTracking();
    void takeSnapshot(const std::string& label);
    void stopTracking();
    
    size_t getCurrentMemoryUsage() const;
    size_t getPeakMemoryUsage() const;
    size_t getMemoryDelta() const;
    
    std::vector<MemorySnapshot> getSnapshots() const;
    MemoryReport generateMemoryReport() const;
    
private:
    size_t getSystemMemoryUsage() const;
    void updateMemoryStats();
    
    struct MemorySnapshot {
        std::string label;
        std::chrono::steady_clock::time_point timestamp;
        size_t memory_usage;
        size_t heap_size;
        size_t stack_size;
    };
};
```

#### 4. ProgressWatchdog (è¿›åº¦ç›‘æ§å™¨)
```cpp
class ProgressWatchdog {
private:
    std::chrono::steady_clock::time_point last_progress_time_;
    std::chrono::seconds stall_threshold_;
    size_t last_processed_tokens_;
    size_t last_ast_nodes_;
    bool is_monitoring_;
    
public:
    void startWatching();
    void reportProgress(size_t tokens_processed, size_t ast_nodes_created);
    void stopWatching();
    
    bool isProgressStalled() const;
    std::chrono::milliseconds getTimeSinceLastProgress() const;
    
    void setStallThreshold(std::chrono::seconds threshold);
    
private:
    bool hasProgressOccurred(size_t tokens, size_t nodes) const;
    void updateProgressTime();
};
```

## ä½¿ç”¨æ–¹æ³•

### ğŸš€ **åŸºæœ¬ä½¿ç”¨**

```cpp
// åœ¨ç¼–è¯‘å™¨ä¸»å‡½æ•°ä¸­å¯ç”¨è®¡æ—¶å™¨
int main(int argc, char* argv[]) {
    auto& timer = CompileTimer::getInstance();
    
    // é…ç½®å®‰å…¨é™åˆ¶
    timer.setTimeoutLimit(std::chrono::seconds(300));  // 5åˆ†é’Ÿè¶…æ—¶
    timer.setMemoryLimit(1024);                         // 1GBå†…å­˜é™åˆ¶
    timer.enableInfiniteLoopDetection(true);
    
    try {
        // å¼€å§‹ç¼–è¯‘
        timer.startPhase("Total_Compilation");
        
        CHTLCompiler compiler(argv[1]);
        auto result = compiler.compile();
        
        timer.endPhase("Total_Compilation");
        
        // ç”ŸæˆæŠ¥å‘Š
        auto report = timer.generateReport();
        timer.exportReport("compilation_report.json", ReportFormat::JSON);
        
        std::cout << "ç¼–è¯‘å®Œæˆï¼è€—æ—¶: " << report.total_time.count() << "ms" << std::endl;
        std::cout << "å³°å€¼å†…å­˜: " << report.peak_memory_mb << "MB" << std::endl;
        
    } catch (const CompilationTimeoutException& e) {
        std::cerr << "ç¼–è¯‘è¶…æ—¶: " << e.what() << std::endl;
        return 1;
    } catch (const MemoryLimitException& e) {
        std::cerr << "å†…å­˜é™åˆ¶è¶…å‡º: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```

### ğŸ” **è¯¦ç»†é˜¶æ®µç›‘æ§**

```cpp
// åœ¨ç¼–è¯‘å™¨å„ä¸ªé˜¶æ®µä½¿ç”¨è®¡æ—¶å™¨
class CHTLCompiler {
public:
    CompilationResult compile(const std::string& source_code) {
        auto& timer = CompileTimer::getInstance();
        
        // è¯æ³•åˆ†æé˜¶æ®µ
        timer.startPhase("Lexical_Analysis");
        auto tokens = lexer_.tokenize(source_code);
        timer.recordEvent("Tokens_Generated", "Count: " + std::to_string(tokens.size()));
        timer.endPhase("Lexical_Analysis");
        
        // è¯­æ³•åˆ†æé˜¶æ®µ
        timer.startPhase("Syntax_Analysis");
        auto ast = parser_.parse(tokens);
        timer.recordEvent("AST_Nodes_Created", "Count: " + std::to_string(ast->getNodeCount()));
        timer.endPhase("Syntax_Analysis");
        
        // è¯­ä¹‰åˆ†æé˜¶æ®µ
        timer.startPhase("Semantic_Analysis");
        semantic_analyzer_.analyze(ast.get());
        timer.endPhase("Semantic_Analysis");
        
        // ä»£ç ç”Ÿæˆé˜¶æ®µ
        timer.startPhase("Code_Generation");
        auto result = code_generator_.generate(ast.get());
        timer.recordEvent("Code_Generated", "Size: " + std::to_string(result.size()));
        timer.endPhase("Code_Generation");
        
        return result;
    }
};
```

### ğŸ“Š **æ€§èƒ½åˆ†æ**

```cpp
// è‡ªåŠ¨æ€§èƒ½åˆ†æ
class PerformanceAnalyzer {
public:
    static void analyzeCompilationPerformance(const TimingReport& report) {
        std::cout << "\n=== CHTLç¼–è¯‘æ€§èƒ½åˆ†æ ===" << std::endl;
        
        // æ€»ä½“æ€§èƒ½
        std::cout << "æ€»ç¼–è¯‘æ—¶é—´: " << report.total_time.count() << "ms" << std::endl;
        std::cout << "å³°å€¼å†…å­˜ä½¿ç”¨: " << report.peak_memory_mb << "MB" << std::endl;
        
        // å„é˜¶æ®µæ€§èƒ½åˆ†æ
        for (const auto& [phase_name, phase_info] : report.phases) {
            double percentage = (double)phase_info.duration.count() / report.total_time.count() * 100.0;
            std::cout << "- " << phase_name << ": " 
                      << phase_info.duration.count() << "ms (" 
                      << std::fixed << std::setprecision(1) << percentage << "%)" << std::endl;
            
            // æ€§èƒ½å»ºè®®
            if (percentage > 40.0) {
                std::cout << "  âš ï¸  è­¦å‘Š: " << phase_name << "å ç”¨æ—¶é—´è¿‡é•¿ï¼Œå»ºè®®ä¼˜åŒ–" << std::endl;
            }
        }
        
        // å†…å­˜æ•ˆç‡åˆ†æ
        if (report.peak_memory_mb > 500) {
            std::cout << "âš ï¸  å†…å­˜ä½¿ç”¨è¾ƒé«˜ï¼Œå»ºè®®æ£€æŸ¥å†…å­˜æ³„æ¼" << std::endl;
        }
        
        // ååé‡åˆ†æ
        if (report.tokens_per_second < 10000) {
            std::cout << "âš ï¸  Tokenå¤„ç†é€Ÿåº¦è¾ƒæ…¢ï¼Œå»ºè®®ä¼˜åŒ–è¯æ³•åˆ†æå™¨" << std::endl;
        }
    }
};
```

## ä¿æŠ¤æœºåˆ¶è¯¦è§£

### â° **è¶…æ—¶ä¿æŠ¤**

```cpp
class TimeoutProtection {
private:
    std::chrono::seconds timeout_limit_;
    std::chrono::steady_clock::time_point start_time_;
    std::atomic<bool> timeout_triggered_;
    
public:
    void startTimeout(std::chrono::seconds limit) {
        timeout_limit_ = limit;
        start_time_ = std::chrono::steady_clock::now();
        timeout_triggered_ = false;
        
        // å¯åŠ¨ç›‘æ§çº¿ç¨‹
        std::thread([this]() {
            std::this_thread::sleep_for(timeout_limit_);
            if (!timeout_triggered_) {
                triggerTimeout();
            }
        }).detach();
    }
    
    void checkTimeout() {
        auto current_time = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
            current_time - start_time_);
        
        if (elapsed >= timeout_limit_) {
            throw CompilationTimeoutException(
                "ç¼–è¯‘è¶…æ—¶: è¶…è¿‡" + std::to_string(timeout_limit_.count()) + "ç§’");
        }
    }
    
private:
    void triggerTimeout() {
        timeout_triggered_ = true;
        // è®¾ç½®å…¨å±€æ ‡å¿—ï¼Œé€šçŸ¥ç¼–è¯‘å™¨åœæ­¢
        CompileTimer::getInstance().forceStop("Timeout exceeded");
    }
};
```

### ğŸ§  **å†…å­˜ç›‘æ§**

```cpp
class MemoryMonitor {
private:
    size_t memory_limit_bytes_;
    std::atomic<size_t> current_memory_;
    std::thread monitor_thread_;
    std::atomic<bool> monitoring_;
    
public:
    void startMonitoring(size_t limit_mb) {
        memory_limit_bytes_ = limit_mb * 1024 * 1024;
        monitoring_ = true;
        
        monitor_thread_ = std::thread([this]() {
            while (monitoring_) {
                updateMemoryUsage();
                checkMemoryLimit();
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        });
    }
    
    void stopMonitoring() {
        monitoring_ = false;
        if (monitor_thread_.joinable()) {
            monitor_thread_.join();
        }
    }
    
private:
    void updateMemoryUsage() {
        // è·å–å½“å‰è¿›ç¨‹å†…å­˜ä½¿ç”¨
        #ifdef _WIN32
            PROCESS_MEMORY_COUNTERS pmc;
            GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));
            current_memory_ = pmc.WorkingSetSize;
        #elif defined(__linux__)
            std::ifstream status("/proc/self/status");
            std::string line;
            while (std::getline(status, line)) {
                if (line.substr(0, 6) == "VmRSS:") {
                    size_t memory_kb = std::stoul(line.substr(7));
                    current_memory_ = memory_kb * 1024;
                    break;
                }
            }
        #elif defined(__APPLE__)
            struct mach_task_basic_info info;
            mach_msg_type_number_t size = MACH_TASK_BASIC_INFO_COUNT;
            kern_return_t kerr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO,
                                         (task_info_t)&info, &size);
            if (kerr == KERN_SUCCESS) {
                current_memory_ = info.resident_size;
            }
        #endif
    }
    
    void checkMemoryLimit() {
        if (current_memory_ > memory_limit_bytes_) {
            throw MemoryLimitException(
                "å†…å­˜ä½¿ç”¨è¶…é™: " + std::to_string(current_memory_ / 1024 / 1024) + 
                "MB > " + std::to_string(memory_limit_bytes_ / 1024 / 1024) + "MB");
        }
    }
};
```

### ğŸ”„ **æ— é™å¾ªç¯æ£€æµ‹**

```cpp
class InfiniteLoopDetector {
private:
    struct CallSiteInfo {
        std::string function_name;
        std::string file_name;
        int line_number;
        size_t call_count;
        std::chrono::steady_clock::time_point last_call;
    };
    
    std::unordered_map<std::string, CallSiteInfo> call_sites_;
    size_t max_call_count_;
    std::chrono::milliseconds max_call_frequency_;
    
public:
    InfiniteLoopDetector() 
        : max_call_count_(10000)
        , max_call_frequency_(std::chrono::milliseconds(1)) {
    }
    
    void recordCall(const std::string& function_name, 
                   const std::string& file_name, 
                   int line_number) {
        std::string call_site = function_name + "@" + file_name + ":" + 
                               std::to_string(line_number);
        
        auto now = std::chrono::steady_clock::now();
        auto& info = call_sites_[call_site];
        
        info.function_name = function_name;
        info.file_name = file_name;
        info.line_number = line_number;
        info.call_count++;
        
        // æ£€æµ‹è°ƒç”¨é¢‘ç‡
        if (info.last_call != std::chrono::steady_clock::time_point{}) {
            auto frequency = now - info.last_call;
            if (frequency < max_call_frequency_ && info.call_count > 100) {
                throw InfiniteLoopException(
                    "æ£€æµ‹åˆ°å¯èƒ½çš„æ— é™å¾ªç¯åœ¨ " + function_name + 
                    " (" + file_name + ":" + std::to_string(line_number) + ")");
            }
        }
        
        info.last_call = now;
        
        // æ£€æµ‹è°ƒç”¨æ¬¡æ•°
        if (info.call_count > max_call_count_) {
            throw InfiniteLoopException(
                "å‡½æ•°è°ƒç”¨æ¬¡æ•°è¿‡å¤š: " + function_name + 
                " å·²è°ƒç”¨ " + std::to_string(info.call_count) + " æ¬¡");
        }
    }
    
    void resetCounters() {
        call_sites_.clear();
    }
    
    std::vector<CallSiteInfo> getSuspiciousCallSites() const {
        std::vector<CallSiteInfo> suspicious;
        for (const auto& [_, info] : call_sites_) {
            if (info.call_count > max_call_count_ / 10) {
                suspicious.push_back(info);
            }
        }
        return suspicious;
    }
};

// å®å®šä¹‰ï¼Œæ–¹ä¾¿åœ¨ä»£ç ä¸­æ’å…¥æ£€æµ‹ç‚¹
#define CHTL_LOOP_CHECK() \
    CompileTimer::getInstance().recordLoopIteration(__FUNCTION__, __FILE__, __LINE__)
```

## æŠ¥å‘Šç”Ÿæˆ

### ğŸ“Š **æŠ¥å‘Šæ ¼å¼**

#### JSONæ ¼å¼æŠ¥å‘Š
```json
{
    "compilation_summary": {
        "total_time_ms": 1234,
        "peak_memory_mb": 156,
        "success": true,
        "compiler_version": "1.0.0",
        "timestamp": "2024-01-15T10:30:00Z"
    },
    "phases": {
        "Lexical_Analysis": {
            "duration_ms": 45,
            "memory_start_mb": 12,
            "memory_peak_mb": 25,
            "memory_end_mb": 20,
            "tokens_generated": 1543,
            "errors": 0,
            "warnings": 2
        },
        "Syntax_Analysis": {
            "duration_ms": 234,
            "memory_start_mb": 20,
            "memory_peak_mb": 67,
            "memory_end_mb": 45,
            "ast_nodes_created": 892,
            "errors": 0,
            "warnings": 1
        }
    },
    "events": [
        {
            "timestamp": "2024-01-15T10:30:01.123Z",
            "type": "phase_start",
            "phase": "Lexical_Analysis"
        },
        {
            "timestamp": "2024-01-15T10:30:01.168Z",
            "type": "phase_end",
            "phase": "Lexical_Analysis"
        }
    ],
    "performance_metrics": {
        "tokens_per_second": 34284,
        "ast_nodes_per_second": 3812,
        "memory_efficiency": 0.85,
        "cpu_utilization": 0.67
    },
    "safety_info": {
        "timeout_enabled": true,
        "timeout_limit_seconds": 300,
        "memory_limit_mb": 1024,
        "infinite_loop_detection": true,
        "violations": []
    }
}
```

#### HTMLæ ¼å¼æŠ¥å‘Š
```html
<!DOCTYPE html>
<html>
<head>
    <title>CHTLç¼–è¯‘æ€§èƒ½æŠ¥å‘Š</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .metric { margin: 10px; padding: 10px; border: 1px solid #ccc; }
        .phase-chart { width: 600px; height: 400px; }
        .memory-chart { width: 800px; height: 300px; }
    </style>
</head>
<body>
    <h1>CHTLç¼–è¯‘æ€§èƒ½æŠ¥å‘Š</h1>
    
    <div class="summary">
        <div class="metric">
            <h3>æ€»ç¼–è¯‘æ—¶é—´</h3>
            <p>1.234 ç§’</p>
        </div>
        <div class="metric">
            <h3>å³°å€¼å†…å­˜</h3>
            <p>156 MB</p>
        </div>
    </div>
    
    <div class="charts">
        <canvas id="phaseChart" class="phase-chart"></canvas>
        <canvas id="memoryChart" class="memory-chart"></canvas>
    </div>
    
    <script>
        // é˜¶æ®µæ—¶é—´åˆ†å¸ƒå›¾
        const phaseCtx = document.getElementById('phaseChart').getContext('2d');
        new Chart(phaseCtx, {
            type: 'pie',
            data: {
                labels: ['è¯æ³•åˆ†æ', 'è¯­æ³•åˆ†æ', 'è¯­ä¹‰åˆ†æ', 'ä»£ç ç”Ÿæˆ'],
                datasets: [{
                    data: [45, 234, 156, 89],
                    backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0']
                }]
            }
        });
        
        // å†…å­˜ä½¿ç”¨è¶‹åŠ¿å›¾
        const memoryCtx = document.getElementById('memoryChart').getContext('2d');
        new Chart(memoryCtx, {
            type: 'line',
            data: {
                labels: ['å¼€å§‹', 'è¯æ³•åˆ†æ', 'è¯­æ³•åˆ†æ', 'è¯­ä¹‰åˆ†æ', 'ä»£ç ç”Ÿæˆ', 'å®Œæˆ'],
                datasets: [{
                    label: 'å†…å­˜ä½¿ç”¨ (MB)',
                    data: [12, 25, 67, 89, 134, 45],
                    borderColor: '#36A2EB',
                    fill: false
                }]
            }
        });
    </script>
</body>
</html>
```

### ğŸ“ˆ **æ€§èƒ½è¶‹åŠ¿åˆ†æ**

```cpp
class PerformanceTrendAnalyzer {
private:
    std::vector<TimingReport> historical_reports_;
    
public:
    void addReport(const TimingReport& report) {
        historical_reports_.push_back(report);
        
        // ä¿æŒæœ€è¿‘100æ¬¡ç¼–è¯‘è®°å½•
        if (historical_reports_.size() > 100) {
            historical_reports_.erase(historical_reports_.begin());
        }
    }
    
    TrendAnalysis analyzeTrends() const {
        TrendAnalysis analysis;
        
        if (historical_reports_.size() < 2) {
            return analysis;
        }
        
        // è®¡ç®—å¹³å‡å€¼å’Œè¶‹åŠ¿
        double total_time_sum = 0;
        double memory_sum = 0;
        
        for (const auto& report : historical_reports_) {
            total_time_sum += report.total_time.count();
            memory_sum += report.peak_memory_mb;
        }
        
        analysis.average_compile_time = total_time_sum / historical_reports_.size();
        analysis.average_memory_usage = memory_sum / historical_reports_.size();
        
        // æ£€æµ‹æ€§èƒ½å›å½’
        auto recent_avg = calculateRecentAverage(10);  // æœ€è¿‘10æ¬¡
        auto baseline_avg = calculateBaselineAverage(); // åŸºå‡†å¹³å‡å€¼
        
        if (recent_avg.compile_time > baseline_avg.compile_time * 1.2) {
            analysis.performance_regression = true;
            analysis.regression_details = "ç¼–è¯‘æ—¶é—´å¢åŠ äº† " + 
                std::to_string((recent_avg.compile_time / baseline_avg.compile_time - 1) * 100) + "%";
        }
        
        return analysis;
    }
    
    struct TrendAnalysis {
        double average_compile_time;
        double average_memory_usage;
        bool performance_regression;
        std::string regression_details;
        std::vector<std::string> recommendations;
    };
};
```

## é…ç½®å’Œå®šåˆ¶

### âš™ï¸ **é…ç½®æ–‡ä»¶**

```ini
# compile_timer_config.ini

[General]
enabled = true
debug_mode = false
report_format = json
report_file = compilation_report.json

[Safety]
timeout_limit_seconds = 300
memory_limit_mb = 1024
infinite_loop_detection = true
max_recursion_depth = 1000

[Monitoring]
memory_check_interval_ms = 100
progress_check_interval_ms = 1000
stall_threshold_seconds = 30

[Performance]
enable_trend_analysis = true
historical_report_count = 100
performance_regression_threshold = 1.2

[Alerts]
email_notifications = false
slack_webhook = ""
alert_threshold_time_ms = 10000
alert_threshold_memory_mb = 500
```

### ğŸ›ï¸ **è¿è¡Œæ—¶é…ç½®**

```cpp
// é€šè¿‡ç¯å¢ƒå˜é‡é…ç½®
void configureFromEnvironment() {
    auto& timer = CompileTimer::getInstance();
    
    // ä»ç¯å¢ƒå˜é‡è¯»å–é…ç½®
    if (auto timeout = std::getenv("CHTL_COMPILE_TIMEOUT")) {
        timer.setTimeoutLimit(std::chrono::seconds(std::stoi(timeout)));
    }
    
    if (auto memory_limit = std::getenv("CHTL_MEMORY_LIMIT")) {
        timer.setMemoryLimit(std::stoi(memory_limit));
    }
    
    if (auto debug_mode = std::getenv("CHTL_DEBUG_TIMER")) {
        timer.enableDebugMode(std::string(debug_mode) == "true");
    }
}

// é€šè¿‡å‘½ä»¤è¡Œå‚æ•°é…ç½®
void configureFromCommandLine(int argc, char* argv[]) {
    auto& timer = CompileTimer::getInstance();
    
    for (int i = 1; i < argc; i++) {
        std::string arg(argv[i]);
        
        if (arg == "--timeout" && i + 1 < argc) {
            timer.setTimeoutLimit(std::chrono::seconds(std::stoi(argv[++i])));
        } else if (arg == "--memory-limit" && i + 1 < argc) {
            timer.setMemoryLimit(std::stoi(argv[++i]));
        } else if (arg == "--enable-timer-debug") {
            timer.enableDebugMode(true);
        } else if (arg == "--disable-infinite-loop-detection") {
            timer.enableInfiniteLoopDetection(false);
        }
    }
}
```

## æœ€ä½³å®è·µ

### âœ… **ä½¿ç”¨å»ºè®®**

1. **åˆç†è®¾ç½®é™åˆ¶**
   ```cpp
   // æ ¹æ®é¡¹ç›®å¤§å°è°ƒæ•´é™åˆ¶
   if (source_file_size > 1_MB) {
       timer.setTimeoutLimit(std::chrono::minutes(10));
       timer.setMemoryLimit(2048);  // 2GB
   } else {
       timer.setTimeoutLimit(std::chrono::minutes(2));
       timer.setMemoryLimit(512);   // 512MB
   }
   ```

2. **åˆ†é˜¶æ®µç›‘æ§**
   ```cpp
   // ç»†ç²’åº¦çš„é˜¶æ®µç›‘æ§
   timer.startPhase("Lexical_Analysis");
   timer.startPhase("Token_Generation");
   // ... å…·ä½“æ“ä½œ
   timer.endPhase("Token_Generation");
   timer.endPhase("Lexical_Analysis");
   ```

3. **å¼‚å¸¸æƒ…å†µå¤„ç†**
   ```cpp
   try {
       compile();
   } catch (const CompilationTimeoutException& e) {
       // ä¿å­˜å½“å‰çŠ¶æ€ï¼Œä¾¿äºè°ƒè¯•
       timer.exportReport("timeout_debug.json", ReportFormat::JSON);
       logError("ç¼–è¯‘è¶…æ—¶: " + std::string(e.what()));
   }
   ```

### ğŸš« **é¿å…çš„åæ¨¡å¼**

```cpp
// âŒ é¿å…ï¼šè¿‡åº¦ç»†åŒ–çš„ç›‘æ§
timer.startPhase("SingleTokenProcessing");  // è¿‡ç»†
processToken();
timer.endPhase("SingleTokenProcessing");

// âœ… æ¨èï¼šåˆç†çš„ç²’åº¦
timer.startPhase("BatchTokenProcessing");
for (auto& token : tokens) {
    processToken(token);
}
timer.endPhase("BatchTokenProcessing");

// âŒ é¿å…ï¼šå¿˜è®°ç»“æŸé˜¶æ®µ
timer.startPhase("Analysis");
performAnalysis();
// å¿˜è®°è°ƒç”¨ timer.endPhase("Analysis");

// âœ… æ¨èï¼šä½¿ç”¨RAII
class ScopedTimer {
public:
    ScopedTimer(const std::string& phase) : phase_(phase) {
        CompileTimer::getInstance().startPhase(phase_);
    }
    ~ScopedTimer() {
        CompileTimer::getInstance().endPhase(phase_);
    }
private:
    std::string phase_;
};
```

---

ç¼–è¯‘è®¡æ—¶å™¨æ˜¯ç¡®ä¿CHTLç¼–è¯‘å™¨ç¨³å®šæ€§å’Œæ€§èƒ½çš„é‡è¦å·¥å…·ã€‚é€šè¿‡ç²¾ç¡®çš„æ—¶é—´æµ‹é‡ã€å†…å­˜ç›‘æ§å’Œå®‰å…¨ä¿æŠ¤æœºåˆ¶ï¼Œå®ƒä¸ºå¼€å‘è€…æä¾›äº†æ·±å…¥äº†è§£ç¼–è¯‘è¿‡ç¨‹çš„èƒ½åŠ›ï¼ŒåŒæ—¶é˜²æ­¢äº†æ½œåœ¨çš„æ— é™å¾ªç¯å’Œèµ„æºè€—å°½é—®é¢˜ã€‚
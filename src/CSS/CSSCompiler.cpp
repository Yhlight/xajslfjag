#include "CSSCompiler.h"
#include <sstream>
#include <regex>
#include <algorithm>
#include <cctype>
#include <iomanip>

// Note: In a real implementation, these would be generated by ANTLR
// For now, we'll create mock implementations

namespace CHTL {

// Mock ANTLR classes (replace with generated code)
namespace {
    class MockCSSLexer {
    public:
        MockCSSLexer(const std::string& input) : input_(input) {}
        // Mock implementation
    private:
        std::string input_;
    };
    
    class MockCSSParser {
    public:
        MockCSSParser(MockCSSLexer& lexer) : lexer_(lexer) {}
        // Mock implementation
        void parse() {
            // Simple CSS parsing logic
        }
    private:
        MockCSSLexer& lexer_;
    };
}

// CSS Node implementations

std::string StylesheetNode::toString() const {
    std::stringstream ss;
    for (const auto& child : children_) {
        ss << child->toString() << "\n";
    }
    return ss.str();
}

std::string RuleSetNode::toString() const {
    std::stringstream ss;
    
    // Output selectors
    for (size_t i = 0; i < selectors_.size(); ++i) {
        if (i > 0) ss << ", ";
        ss << selectors_[i];
    }
    
    ss << " {\n";
    
    // Output declarations
    for (const auto& child : children_) {
        if (child->getType() == CSSNodeType::DECLARATION) {
            ss << "  " << child->toString() << "\n";
        }
    }
    
    ss << "}";
    
    return ss.str();
}

std::string AtRuleNode::toString() const {
    std::stringstream ss;
    ss << keyword_;
    
    if (!content_.empty()) {
        ss << " " << content_;
    }
    
    if (!children_.empty()) {
        ss << " {\n";
        for (const auto& child : children_) {
            ss << child->toString() << "\n";
        }
        ss << "}";
    } else {
        ss << ";";
    }
    
    return ss.str();
}

std::string DeclarationNode::toString() const {
    std::stringstream ss;
    ss << property_ << ": " << value_;
    if (important_) {
        ss << " !important";
    }
    ss << ";";
    return ss.str();
}

// CSSCompilerANTLR Implementation

CSSCompilerANTLR::CSSCompilerANTLR() {}

CSSCompilerANTLR::~CSSCompilerANTLR() = default;

CompileResult CSSCompilerANTLR::compile(const std::string& code, const CompileOptions& options) {
    CompileResult result;
    
    try {
        // Parse CSS
        auto ast = parse(code);
        if (!ast) {
            result.success = false;
            result.errors.push_back("Failed to parse CSS");
            return result;
        }
        
        // Generate CSS
        std::string css = generate(ast, options);
        
        // Apply preprocessor if configured
        if (!preprocessor_.empty()) {
            // Apply preprocessor transformations
            // This would integrate with SASS, LESS, etc.
        }
        
        // Add vendor prefixes if enabled
        if (autoprefixer_) {
            css = addPrefixes(css);
        }
        
        // Optimize CSS
        css = optimize(css, options);
        
        // Minify or prettify
        if (options.minify) {
            css = minify(css);
        } else if (options.prettify) {
            css = prettify(css);
        }
        
        result.cssOutput = css;
        result.success = true;
        
    } catch (const std::exception& e) {
        result.success = false;
        result.errors.push_back(std::string("CSS compilation error: ") + e.what());
    }
    
    return result;
}

bool CSSCompilerANTLR::validate(const std::string& code) {
    try {
        auto ast = parse(code);
        return ast != nullptr;
    } catch (...) {
        return false;
    }
}

void CSSCompilerANTLR::setPreprocessor(const std::string& preprocessor) {
    preprocessor_ = preprocessor;
}

void CSSCompilerANTLR::setAutoprefixer(bool enable) {
    autoprefixer_ = enable;
}

std::shared_ptr<StylesheetNode> CSSCompilerANTLR::parse(const std::string& code) {
    // This would use ANTLR-generated parser
    // For now, create a simple mock implementation
    
    auto stylesheet = std::make_shared<StylesheetNode>();
    
    // Simple regex-based parsing (replace with ANTLR)
    std::regex ruleRegex(R"(([^{}]+)\{([^}]+)\})");
    std::regex declRegex(R"(\s*([^:]+):\s*([^;]+);?)");
    
    auto rulesBegin = std::sregex_iterator(code.begin(), code.end(), ruleRegex);
    auto rulesEnd = std::sregex_iterator();
    
    for (auto it = rulesBegin; it != rulesEnd; ++it) {
        std::smatch match = *it;
        std::string selector = match[1];
        std::string declarations = match[2];
        
        auto ruleSet = std::make_shared<RuleSetNode>();
        
        // Parse selectors
        std::stringstream ss(selector);
        std::string sel;
        std::vector<std::string> selectors;
        while (std::getline(ss, sel, ',')) {
            // Trim whitespace
            sel.erase(0, sel.find_first_not_of(" \t\n\r"));
            sel.erase(sel.find_last_not_of(" \t\n\r") + 1);
            if (!sel.empty()) {
                selectors.push_back(sel);
            }
        }
        ruleSet->setSelectors(selectors);
        
        // Parse declarations
        auto declBegin = std::sregex_iterator(declarations.begin(), declarations.end(), declRegex);
        auto declEnd = std::sregex_iterator();
        
        for (auto dit = declBegin; dit != declEnd; ++dit) {
            std::smatch declMatch = *dit;
            std::string property = declMatch[1];
            std::string value = declMatch[2];
            
            // Trim whitespace
            property.erase(0, property.find_first_not_of(" \t\n\r"));
            property.erase(property.find_last_not_of(" \t\n\r") + 1);
            value.erase(0, value.find_first_not_of(" \t\n\r"));
            value.erase(value.find_last_not_of(" \t\n\r") + 1);
            
            // Check for !important
            bool important = false;
            size_t importantPos = value.find("!important");
            if (importantPos != std::string::npos) {
                important = true;
                value = value.substr(0, importantPos);
                value.erase(value.find_last_not_of(" \t\n\r") + 1);
            }
            
            auto decl = std::make_shared<DeclarationNode>(property, value, important);
            ruleSet->addChild(decl);
        }
        
        stylesheet->addChild(ruleSet);
    }
    
    return stylesheet;
}

std::string CSSCompilerANTLR::generate(std::shared_ptr<StylesheetNode> ast, const CompileOptions& options) {
    return ast->toString();
}

std::string CSSCompilerANTLR::optimize(const std::string& css, const CompileOptions& options) {
    std::string optimized = css;
    
    // Remove duplicate rules
    // Merge similar selectors
    // Optimize color values (e.g., #ffffff -> #fff)
    // Remove unused CSS (would require DOM analysis)
    
    return optimized;
}

std::string CSSCompilerANTLR::addPrefixes(const std::string& css) {
    std::string prefixed = css;
    
    // Properties that need prefixes
    std::vector<std::pair<std::string, std::vector<std::string>>> prefixMap = {
        {"transform", {"-webkit-transform", "-moz-transform", "-ms-transform"}},
        {"transition", {"-webkit-transition", "-moz-transition"}},
        {"animation", {"-webkit-animation", "-moz-animation"}},
        {"box-shadow", {"-webkit-box-shadow", "-moz-box-shadow"}},
        {"border-radius", {"-webkit-border-radius", "-moz-border-radius"}},
        {"flex", {"-webkit-flex", "-ms-flex"}},
        {"flexbox", {"-webkit-box", "-moz-box", "-ms-flexbox"}},
        {"user-select", {"-webkit-user-select", "-moz-user-select", "-ms-user-select"}}
    };
    
    for (const auto& [property, prefixes] : prefixMap) {
        std::regex propRegex("(^|\\s)" + property + "\\s*:");
        std::smatch match;
        
        std::string::const_iterator searchStart(prefixed.cbegin());
        while (std::regex_search(searchStart, prefixed.cend(), match, propRegex)) {
            size_t pos = match.position() + std::distance(prefixed.cbegin(), searchStart);
            
            // Find the end of this declaration
            size_t endPos = prefixed.find(';', pos);
            if (endPos == std::string::npos) {
                endPos = prefixed.find('}', pos);
            }
            
            if (endPos != std::string::npos) {
                std::string declaration = prefixed.substr(pos, endPos - pos + 1);
                std::string prefixedDeclarations;
                
                // Add prefixed versions
                for (const auto& prefix : prefixes) {
                    std::string prefixedDecl = declaration;
                    size_t propPos = prefixedDecl.find(property);
                    if (propPos != std::string::npos) {
                        prefixedDecl.replace(propPos, property.length(), prefix);
                        prefixedDeclarations += "\n  " + prefixedDecl;
                    }
                }
                
                // Insert prefixed declarations before the original
                prefixed.insert(pos, prefixedDeclarations + "\n  ");
                searchStart = prefixed.cbegin() + pos + prefixedDeclarations.length() + declaration.length();
            } else {
                break;
            }
        }
    }
    
    return prefixed;
}

std::string CSSCompilerANTLR::minify(const std::string& css) {
    std::string minified;
    minified.reserve(css.size());
    
    bool inString = false;
    char stringChar = 0;
    bool lastWasSpace = false;
    
    for (size_t i = 0; i < css.length(); ++i) {
        char ch = css[i];
        
        // Handle strings
        if ((ch == '"' || ch == '\'') && (i == 0 || css[i-1] != '\\')) {
            if (!inString) {
                inString = true;
                stringChar = ch;
            } else if (ch == stringChar) {
                inString = false;
            }
            minified += ch;
            continue;
        }
        
        if (inString) {
            minified += ch;
            continue;
        }
        
        // Skip comments
        if (ch == '/' && i + 1 < css.length() && css[i + 1] == '*') {
            i += 2;
            while (i + 1 < css.length() && !(css[i] == '*' && css[i + 1] == '/')) {
                ++i;
            }
            ++i; // Skip the closing /
            continue;
        }
        
        // Handle whitespace
        if (std::isspace(ch)) {
            if (!lastWasSpace && !minified.empty() && 
                minified.back() != '{' && minified.back() != '}' && 
                minified.back() != ';' && minified.back() != ':') {
                minified += ' ';
                lastWasSpace = true;
            }
        } else {
            minified += ch;
            lastWasSpace = false;
            
            // Remove spaces around certain characters
            if ((ch == '{' || ch == '}' || ch == ':' || ch == ';' || ch == ',') && 
                !minified.empty() && minified[minified.length() - 2] == ' ') {
                minified.erase(minified.length() - 2, 1);
            }
        }
    }
    
    // Remove trailing semicolon before }
    size_t pos = 0;
    while ((pos = minified.find(";}", pos)) != std::string::npos) {
        minified.erase(pos, 1);
    }
    
    return minified;
}

std::string CSSCompilerANTLR::prettify(const std::string& css) {
    std::string pretty;
    int indentLevel = 0;
    const std::string indent = "  ";
    bool inProperty = false;
    
    for (size_t i = 0; i < css.length(); ++i) {
        char ch = css[i];
        
        if (ch == '{') {
            pretty += " {\n";
            ++indentLevel;
            inProperty = false;
        } else if (ch == '}') {
            if (!pretty.empty() && pretty.back() != '\n') {
                pretty += '\n';
            }
            --indentLevel;
            for (int j = 0; j < indentLevel; ++j) {
                pretty += indent;
            }
            pretty += "}\n";
            inProperty = false;
        } else if (ch == ';') {
            pretty += ";\n";
            inProperty = false;
        } else if (ch == ':') {
            pretty += ": ";
            inProperty = true;
        } else if (ch == ',') {
            if (!inProperty) {
                pretty += ",\n";
                for (int j = 0; j < indentLevel; ++j) {
                    pretty += indent;
                }
            } else {
                pretty += ", ";
            }
        } else if (!std::isspace(ch)) {
            if (pretty.empty() || pretty.back() == '\n') {
                for (int j = 0; j < indentLevel; ++j) {
                    pretty += indent;
                }
            }
            pretty += ch;
        } else if (!pretty.empty() && pretty.back() != ' ' && pretty.back() != '\n') {
            pretty += ' ';
        }
    }
    
    return pretty;
}

// CSS Utilities Implementation

std::string CSSUtil::hexToRgb(const std::string& hex) {
    std::string h = hex;
    if (h[0] == '#') h = h.substr(1);
    
    if (h.length() == 3) {
        h = std::string(2, h[0]) + std::string(2, h[1]) + std::string(2, h[2]);
    }
    
    if (h.length() != 6) return hex;
    
    int r = std::stoi(h.substr(0, 2), nullptr, 16);
    int g = std::stoi(h.substr(2, 2), nullptr, 16);
    int b = std::stoi(h.substr(4, 2), nullptr, 16);
    
    return "rgb(" + std::to_string(r) + ", " + std::to_string(g) + ", " + std::to_string(b) + ")";
}

std::string CSSUtil::rgbToHex(int r, int g, int b) {
    std::stringstream ss;
    ss << "#" << std::hex << std::setfill('0') 
       << std::setw(2) << r 
       << std::setw(2) << g 
       << std::setw(2) << b;
    return ss.str();
}

std::string CSSUtil::hslToRgb(int h, int s, int l) {
    double hue = h / 360.0;
    double sat = s / 100.0;
    double light = l / 100.0;
    
    auto hueToRgb = [](double p, double q, double t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1.0/6) return p + (q - p) * 6 * t;
        if (t < 1.0/2) return q;
        if (t < 2.0/3) return p + (q - p) * (2.0/3 - t) * 6;
        return p;
    };
    
    double r, g, b;
    
    if (sat == 0) {
        r = g = b = light;
    } else {
        double q = light < 0.5 ? light * (1 + sat) : light + sat - light * sat;
        double p = 2 * light - q;
        r = hueToRgb(p, q, hue + 1.0/3);
        g = hueToRgb(p, q, hue);
        b = hueToRgb(p, q, hue - 1.0/3);
    }
    
    return "rgb(" + std::to_string(int(r * 255)) + ", " + 
                    std::to_string(int(g * 255)) + ", " + 
                    std::to_string(int(b * 255)) + ")";
}

int CSSUtil::calculateSpecificity(const std::string& selector) {
    int ids = 0, classes = 0, elements = 0;
    
    // Count IDs
    size_t pos = 0;
    while ((pos = selector.find('#', pos)) != std::string::npos) {
        ids++;
        pos++;
    }
    
    // Count classes and pseudo-classes
    pos = 0;
    while ((pos = selector.find('.', pos)) != std::string::npos) {
        classes++;
        pos++;
    }
    pos = 0;
    while ((pos = selector.find(':', pos)) != std::string::npos) {
        classes++;
        pos++;
    }
    
    // Count elements (simplified)
    std::regex elementRegex(R"(\b[a-zA-Z]+\b)");
    auto begin = std::sregex_iterator(selector.begin(), selector.end(), elementRegex);
    auto end = std::sregex_iterator();
    elements = std::distance(begin, end);
    
    return ids * 100 + classes * 10 + elements;
}

std::vector<std::string> CSSUtil::getVendorPrefixes(const std::string& property) {
    static const std::unordered_map<std::string, std::vector<std::string>> prefixMap = {
        {"transform", {"-webkit-", "-moz-", "-ms-", "-o-"}},
        {"transition", {"-webkit-", "-moz-", "-o-"}},
        {"animation", {"-webkit-", "-moz-", "-o-"}},
        {"box-shadow", {"-webkit-", "-moz-"}},
        {"border-radius", {"-webkit-", "-moz-"}},
        {"flex", {"-webkit-", "-ms-"}},
        {"user-select", {"-webkit-", "-moz-", "-ms-"}}
    };
    
    auto it = prefixMap.find(property);
    if (it != prefixMap.end()) {
        return it->second;
    }
    
    return {};
}

bool CSSUtil::isValidProperty(const std::string& property) {
    // Simplified property validation
    static const std::unordered_set<std::string> validProperties = {
        "color", "background", "background-color", "border", "margin", "padding",
        "font", "font-size", "font-family", "font-weight", "text-align",
        "width", "height", "position", "display", "float", "clear",
        "z-index", "opacity", "transform", "transition", "animation"
        // Add more as needed
    };
    
    return validProperties.find(property) != validProperties.end();
}

bool CSSUtil::isValidValue(const std::string& property, const std::string& value) {
    // Simplified value validation
    // In a real implementation, this would be much more comprehensive
    
    if (property == "color" || property == "background-color") {
        // Check if it's a valid color
        return value[0] == '#' || value.substr(0, 3) == "rgb" || 
               value.substr(0, 3) == "hsl" || value == "transparent";
    }
    
    if (property == "display") {
        static const std::unordered_set<std::string> displayValues = {
            "none", "block", "inline", "inline-block", "flex", "grid"
        };
        return displayValues.find(value) != displayValues.end();
    }
    
    // For now, accept all other values
    return true;
}

} // namespace CHTL
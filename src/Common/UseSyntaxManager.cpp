#include "UseSyntaxManager.h"
#include "GlobalMap.h"
#include "Context.h"
#include <algorithm>
#include <regex>
#include <sstream>

namespace CHTL {

// ===== UseSyntaxManager Implementation =====

UseSyntaxManager::UseSyntaxManager()
    : enable_html5_declaration(true)
    , enable_config_groups(true)
    , enable_dependency_tracking(true)
    , enable_conflict_detection(true)
    , strict_mode(false) {
    initializePredefinedConfigurations();
    initializeHTML5Templates();
}

void UseSyntaxManager::initializePredefinedConfigurations() {
    // 初始化预定义配置组
    
    // Basic 配置组
    ConfigurationUse basic_config;
    basic_config.name = "Basic";
    basic_config.type = UseSyntaxType::CONFIG_GROUP;
    basic_config.description = "基础配置组";
    
    basic_config.configuration_values = {
        {"DISABLE_STYLE_AUTO_ADD_CLASS", "false"},
        {"DISABLE_STYLE_AUTO_ADD_ID", "false"},
        {"DISABLE_SCRIPT_AUTO_ADD_CLASS", "false"},
        {"DISABLE_SCRIPT_AUTO_ADD_ID", "false"},
        {"DEFAULT_NAMESPACE", ""},
        {"STRICT_MODE", "false"}
    };
    
    predefined_configurations["Basic"] = basic_config;
    
    // Strict 配置组
    ConfigurationUse strict_config;
    strict_config.name = "Strict";
    strict_config.type = UseSyntaxType::CONFIG_GROUP;
    strict_config.description = "严格模式配置组";
    
    strict_config.configuration_values = {
        {"DISABLE_STYLE_AUTO_ADD_CLASS", "true"},
        {"DISABLE_STYLE_AUTO_ADD_ID", "true"},
        {"DISABLE_SCRIPT_AUTO_ADD_CLASS", "true"},
        {"DISABLE_SCRIPT_AUTO_ADD_ID", "true"},
        {"STRICT_MODE", "true"},
        {"REQUIRE_EXPLICIT_TYPES", "true"}
    };
    
    predefined_configurations["Strict"] = strict_config;
    
    // Responsive 配置组
    ConfigurationUse responsive_config;
    responsive_config.name = "Responsive";
    responsive_config.type = UseSyntaxType::CONFIG_GROUP;
    responsive_config.description = "响应式设计配置组";
    
    responsive_config.configuration_values = {
        {"ENABLE_RESPONSIVE_GRID", "true"},
        {"ENABLE_MEDIA_QUERIES", "true"},
        {"DEFAULT_BREAKPOINTS", "sm:576px,md:768px,lg:992px,xl:1200px"},
        {"ENABLE_VIEWPORT_META", "true"}
    };
    
    predefined_configurations["Responsive"] = responsive_config;
}

void UseSyntaxManager::initializeHTML5Templates() {
    // 初始化HTML5文档模板
    
    // 标准HTML5模板
    HTML5Declaration standard_html5;
    standard_html5.doctype = "<!DOCTYPE html>";
    standard_html5.html_attributes = {{"lang", "en"}};
    standard_html5.meta_tags = {
        {"charset", "UTF-8"},
        {"name=\"viewport\"", "width=device-width, initial-scale=1.0"},
        {"name=\"description\"", "Generated by CHTL Compiler"}
    };
    standard_html5.default_title = "CHTL Document";
    standard_html5.include_responsive_meta = true;
    standard_html5.include_compatibility_tags = true;
    
    html5_templates["standard"] = standard_html5;
    
    // 移动端优化模板
    HTML5Declaration mobile_html5;
    mobile_html5.doctype = "<!DOCTYPE html>";
    mobile_html5.html_attributes = {{"lang", "en"}};
    mobile_html5.meta_tags = {
        {"charset", "UTF-8"},
        {"name=\"viewport\"", "width=device-width, initial-scale=1.0, user-scalable=no"},
        {"name=\"mobile-web-app-capable\"", "yes"},
        {"name=\"apple-mobile-web-app-capable\"", "yes"},
        {"name=\"apple-mobile-web-app-status-bar-style\"", "black-translucent"}
    };
    mobile_html5.default_title = "CHTL Mobile App";
    mobile_html5.include_responsive_meta = true;
    mobile_html5.include_compatibility_tags = true;
    
    html5_templates["mobile"] = mobile_html5;
}

UseSyntaxParseResult UseSyntaxManager::parseUseSyntax(const std::string& use_statement) {
    UseSyntaxParseResult result;
    result.success = false;
    
    if (use_statement.empty()) {
        result.errors.push_back("use语句不能为空");
        return result;
    }
    
    // 移除首尾空格和分号
    std::string cleaned = use_statement;
    cleaned.erase(0, cleaned.find_first_not_of(" \t\n\r"));
    cleaned.erase(cleaned.find_last_not_of(" \t\n\r;") + 1);
    
    // 检查是否以use开头
    if (cleaned.substr(0, 3) != "use") {
        result.errors.push_back("语句必须以'use'开头");
        return result;
    }
    
    // 移除use关键字
    std::string content = cleaned.substr(3);
    content.erase(0, content.find_first_not_of(" \t"));
    
    // 解析不同类型的use语句
    if (content == "html5") {
        result = parseHTML5Declaration(content);
    } else if (content.find("@Config") == 0) {
        result = parseConfigurationUse(content);
    } else if (content.find("[Configuration]") == 0) {
        result = parseExplicitConfigurationUse(content);
    } else {
        result.errors.push_back("未识别的use语句类型: " + content);
        return result;
    }
    
    // 验证解析结果
    if (result.success) {
        if (!validateUseSyntax(result)) {
            result.success = false;
            result.errors.push_back("use语句验证失败");
        }
    }
    
    return result;
}

UseSyntaxParseResult UseSyntaxManager::parseHTML5Declaration(const std::string& content) {
    UseSyntaxParseResult result;
    result.type = UseSyntaxType::HTML5_DECLARATION;
    result.original_statement = "use " + content;
    
    if (content == "html5") {
        // 使用标准HTML5模板
        result.html5_declaration = html5_templates["standard"];
        result.success = true;
    } else {
        // 可能有额外参数，如 use html5(mobile)
        std::regex html5_pattern(R"(html5\s*\(\s*([^)]+)\s*\))");
        std::smatch matches;
        
        if (std::regex_match(content, matches, html5_pattern)) {
            std::string template_name = matches[1].str();
            
            auto template_it = html5_templates.find(template_name);
            if (template_it != html5_templates.end()) {
                result.html5_declaration = template_it->second;
                result.success = true;
            } else {
                result.errors.push_back("未知的HTML5模板: " + template_name);
            }
        } else {
            result.errors.push_back("HTML5声明语法错误");
        }
    }
    
    return result;
}

UseSyntaxParseResult UseSyntaxManager::parseConfigurationUse(const std::string& content) {
    UseSyntaxParseResult result;
    result.type = UseSyntaxType::CONFIG_GROUP;
    result.original_statement = "use " + content;
    
    // 解析 @Config ConfigName 语法
    std::regex config_pattern(R"(@Config\s+([A-Za-z_][A-Za-z0-9_]*))");
    std::smatch matches;
    
    if (std::regex_match(content, matches, config_pattern)) {
        std::string config_name = matches[1].str();
        
        auto config_it = predefined_configurations.find(config_name);
        if (config_it != predefined_configurations.end()) {
            result.configuration_use = config_it->second;
            result.configuration_name = config_name;
            result.success = true;
        } else {
            result.errors.push_back("未知的配置组: " + config_name);
        }
    } else {
        result.errors.push_back("配置组使用语法错误");
    }
    
    return result;
}

UseSyntaxParseResult UseSyntaxManager::parseExplicitConfigurationUse(const std::string& content) {
    UseSyntaxParseResult result;
    result.type = UseSyntaxType::EXPLICIT_CONFIG;
    result.original_statement = "use " + content;
    
    // 解析 [Configuration] @Config ConfigName 语法
    std::regex explicit_config_pattern(R"(\[Configuration\]\s+@Config\s+([A-Za-z_][A-Za-z0-9_]*))");
    std::smatch matches;
    
    if (std::regex_match(content, matches, explicit_config_pattern)) {
        std::string config_name = matches[1].str();
        
        auto config_it = predefined_configurations.find(config_name);
        if (config_it != predefined_configurations.end()) {
            result.configuration_use = config_it->second;
            result.configuration_name = config_name;
            result.is_explicit_configuration = true;
            result.success = true;
        } else {
            result.errors.push_back("未知的配置组: " + config_name);
        }
    } else {
        result.errors.push_back("显式配置组使用语法错误");
    }
    
    return result;
}

bool UseSyntaxManager::validateUseSyntax(const UseSyntaxParseResult& result) const {
    if (!result.success) return false;
    
    switch (result.type) {
        case UseSyntaxType::HTML5_DECLARATION:
            return validateHTML5Declaration(result.html5_declaration);
            
        case UseSyntaxType::CONFIG_GROUP:
        case UseSyntaxType::EXPLICIT_CONFIG:
            return validateConfigurationUse(result.configuration_use);
            
        default:
            return false;
    }
}

bool UseSyntaxManager::validateHTML5Declaration(const HTML5Declaration& declaration) const {
    // 验证doctype
    if (declaration.doctype.empty() || declaration.doctype.find("<!DOCTYPE") != 0) {
        return false;
    }
    
    // 验证meta标签
    for (const auto& [name, content] : declaration.meta_tags) {
        if (name.empty() || content.empty()) {
            return false;
        }
    }
    
    return true;
}

bool UseSyntaxManager::validateConfigurationUse(const ConfigurationUse& config_use) const {
    // 验证配置名称
    if (config_use.name.empty()) {
        return false;
    }
    
    // 验证配置值
    for (const auto& [key, value] : config_use.configuration_values) {
        if (key.empty()) {
            return false;
        }
        // 值可以为空，表示清除配置
    }
    
    return true;
}

bool UseSyntaxManager::processUseSyntax(const UseSyntaxParseResult& result) {
    if (!result.success) {
        addError("无法处理失败的use语句");
        return false;
    }
    
    switch (result.type) {
        case UseSyntaxType::HTML5_DECLARATION:
            return processHTML5Declaration(result);
            
        case UseSyntaxType::CONFIG_GROUP:
        case UseSyntaxType::EXPLICIT_CONFIG:
            return processConfigurationUse(result);
            
        default:
            addError("未知的use语句类型");
            return false;
    }
}

bool UseSyntaxManager::processHTML5Declaration(const UseSyntaxParseResult& result) {
    if (current_html5_declaration.has_value()) {
        addWarning("HTML5声明已存在，将被覆盖");
    }
    
    current_html5_declaration = result.html5_declaration;
    
    // 记录使用的声明
    used_declarations.push_back(result);
    
    return true;
}

bool UseSyntaxManager::processConfigurationUse(const UseSyntaxParseResult& result) {
    const auto& config = result.configuration_use;
    
    // 检查依赖关系
    if (enable_dependency_tracking) {
        std::vector<std::string> deps = getConfigurationDependencies(config.name);
        for (const auto& dep : deps) {
            if (!hasConfiguration(dep)) {
                addError("配置组 '" + config.name + "' 依赖于未加载的配置: " + dep);
                return false;
            }
        }
    }
    
    // 检查冲突
    if (enable_conflict_detection) {
        auto conflicts = detectConfigurationConflicts(config);
        if (!conflicts.empty()) {
            if (strict_mode) {
                addError("配置组 '" + config.name + "' 与现有配置冲突");
                return false;
            } else {
                for (const auto& conflict : conflicts) {
                    addWarning("配置冲突: " + conflict);
                }
            }
        }
    }
    
    // 应用配置
    applyConfiguration(config);
    
    // 记录使用的配置
    used_configurations[config.name] = config;
    used_declarations.push_back(result);
    
    return true;
}

void UseSyntaxManager::applyConfiguration(const ConfigurationUse& config) {
    for (const auto& [key, value] : config.configuration_values) {
        current_configuration[key] = value;
    }
}

std::vector<std::string> UseSyntaxManager::getConfigurationDependencies(const std::string& config_name) const {
    // 在实际实现中，这些依赖关系可能来自配置文件或预定义规则
    std::unordered_map<std::string, std::vector<std::string>> dependencies = {
        {"Responsive", {"Basic"}},
        {"Advanced", {"Basic", "Responsive"}},
        {"Strict", {}}
    };
    
    auto it = dependencies.find(config_name);
    if (it != dependencies.end()) {
        return it->second;
    }
    
    return {};
}

std::vector<std::string> UseSyntaxManager::detectConfigurationConflicts(const ConfigurationUse& config) const {
    std::vector<std::string> conflicts;
    
    for (const auto& [key, new_value] : config.configuration_values) {
        auto current_it = current_configuration.find(key);
        if (current_it != current_configuration.end()) {
            if (current_it->second != new_value) {
                conflicts.push_back("配置项 '" + key + "' 从 '" + current_it->second + "' 变更为 '" + new_value + "'");
            }
        }
    }
    
    return conflicts;
}

std::string UseSyntaxManager::generateHTML5Document(const std::string& body_content) const {
    if (!current_html5_declaration.has_value()) {
        addError("没有HTML5声明，无法生成文档");
        return "";
    }
    
    const auto& html5 = current_html5_declaration.value();
    std::stringstream html;
    
    // DOCTYPE
    html << html5.doctype << "\n";
    
    // HTML标签
    html << "<html";
    for (const auto& [attr, value] : html5.html_attributes) {
        html << " " << attr << "=\"" << value << "\"";
    }
    html << ">\n";
    
    // HEAD部分
    html << "<head>\n";
    
    // Meta标签
    for (const auto& [name, content] : html5.meta_tags) {
        html << "  <meta " << name << " content=\"" << content << "\">\n";
    }
    
    // 标题
    html << "  <title>" << html5.default_title << "</title>\n";
    
    // 兼容性标签
    if (html5.include_compatibility_tags) {
        html << "  <!--[if lt IE 9]>\n";
        html << "    <script src=\"https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js\"></script>\n";
        html << "    <script src=\"https://oss.maxcdn.com/respond/1.4.2/respond.min.js\"></script>\n";
        html << "  <![endif]-->\n";
    }
    
    html << "</head>\n";
    
    // BODY部分
    html << "<body>\n";
    html << body_content;
    html << "\n</body>\n";
    
    html << "</html>\n";
    
    return html.str();
}

std::string UseSyntaxManager::generateConfigurationJavaScript() const {
    std::stringstream js;
    
    js << "// CHTL Configuration\n";
    js << "window.CHTLConfig = {\n";
    
    bool first = true;
    for (const auto& [key, value] : current_configuration) {
        if (!first) js << ",\n";
        first = false;
        
        js << "  " << key << ": ";
        
        // 根据值的类型生成适当的JavaScript
        if (value == "true" || value == "false") {
            js << value; // 布尔值
        } else if (std::regex_match(value, std::regex(R"(\d+)"))) {
            js << value; // 数字
        } else {
            js << "\"" << escapeJavaScriptString(value) << "\""; // 字符串
        }
    }
    
    js << "\n};\n\n";
    
    // 添加配置访问函数
    js << "// Configuration access functions\n";
    js << "window.CHTLConfig.get = function(key) {\n";
    js << "  return this[key];\n";
    js << "};\n\n";
    
    js << "window.CHTLConfig.set = function(key, value) {\n";
    js << "  this[key] = value;\n";
    js << "};\n\n";
    
    js << "window.CHTLConfig.has = function(key) {\n";
    js << "  return this.hasOwnProperty(key);\n";
    js << "};\n";
    
    return js.str();
}

// 配置管理
void UseSyntaxManager::addConfiguration(const std::string& name, const ConfigurationUse& config) {
    predefined_configurations[name] = config;
}

void UseSyntaxManager::removeConfiguration(const std::string& name) {
    predefined_configurations.erase(name);
    used_configurations.erase(name);
}

bool UseSyntaxManager::hasConfiguration(const std::string& name) const {
    return used_configurations.find(name) != used_configurations.end();
}

ConfigurationUse UseSyntaxManager::getConfiguration(const std::string& name) const {
    auto it = used_configurations.find(name);
    if (it != used_configurations.end()) {
        return it->second;
    }
    return ConfigurationUse(); // 返回空配置
}

std::string UseSyntaxManager::getConfigurationValue(const std::string& key) const {
    auto it = current_configuration.find(key);
    if (it != current_configuration.end()) {
        return it->second;
    }
    return "";
}

void UseSyntaxManager::setConfigurationValue(const std::string& key, const std::string& value) {
    current_configuration[key] = value;
}

std::vector<std::string> UseSyntaxManager::getAllConfigurationKeys() const {
    std::vector<std::string> keys;
    for (const auto& [key, value] : current_configuration) {
        keys.push_back(key);
    }
    return keys;
}

std::unordered_map<std::string, std::string> UseSyntaxManager::getAllConfigurations() const {
    return current_configuration;
}

// HTML5模板管理
void UseSyntaxManager::addHTML5Template(const std::string& name, const HTML5Declaration& declaration) {
    html5_templates[name] = declaration;
}

void UseSyntaxManager::removeHTML5Template(const std::string& name) {
    html5_templates.erase(name);
}

bool UseSyntaxManager::hasHTML5Template(const std::string& name) const {
    return html5_templates.find(name) != html5_templates.end();
}

HTML5Declaration UseSyntaxManager::getHTML5Template(const std::string& name) const {
    auto it = html5_templates.find(name);
    if (it != html5_templates.end()) {
        return it->second;
    }
    return HTML5Declaration(); // 返回空声明
}

std::optional<HTML5Declaration> UseSyntaxManager::getCurrentHTML5Declaration() const {
    return current_html5_declaration;
}

// 选项配置
void UseSyntaxManager::enableHTML5Declaration(bool enable) {
    enable_html5_declaration = enable;
}

void UseSyntaxManager::enableConfigGroups(bool enable) {
    enable_config_groups = enable;
}

void UseSyntaxManager::enableDependencyTracking(bool enable) {
    enable_dependency_tracking = enable;
}

void UseSyntaxManager::enableConflictDetection(bool enable) {
    enable_conflict_detection = enable;
}

void UseSyntaxManager::setStrictMode(bool strict) {
    strict_mode = strict;
}

// 验证和检查
bool UseSyntaxManager::isValidUseSyntax(const std::string& use_statement) const {
    auto result = const_cast<UseSyntaxManager*>(this)->parseUseSyntax(use_statement);
    return result.success;
}

std::vector<std::string> UseSyntaxManager::validateFilePosition(const std::vector<std::string>& file_lines, int use_line) const {
    std::vector<std::string> errors;
    
    // use语句必须在文件开头（除了空行和注释）
    for (int i = 0; i < use_line; ++i) {
        std::string line = file_lines[i];
        
        // 移除首尾空格
        line.erase(0, line.find_first_not_of(" \t\n\r"));
        line.erase(line.find_last_not_of(" \t\n\r") + 1);
        
        // 跳过空行
        if (line.empty()) continue;
        
        // 跳过注释行
        if (line.substr(0, 2) == "//" || line.substr(0, 2) == "--") continue;
        
        // 允许其他use语句
        if (line.substr(0, 3) == "use") continue;
        
        // 如果遇到其他内容，则位置错误
        errors.push_back("use语句必须位于文件开头，第 " + std::to_string(i + 1) + " 行包含其他内容: " + line);
    }
    
    return errors;
}

std::vector<std::string> UseSyntaxManager::getUseSuggestions(const std::string& partial_statement) const {
    std::vector<std::string> suggestions;
    
    // HTML5声明建议
    if (enable_html5_declaration) {
        if (partial_statement.empty() || "use html5".find(partial_statement) == 0) {
            suggestions.push_back("use html5;");
        }
        
        for (const auto& [name, declaration] : html5_templates) {
            std::string suggestion = "use html5(" + name + ");";
            if (suggestion.find(partial_statement) == 0) {
                suggestions.push_back(suggestion);
            }
        }
    }
    
    // 配置组建议
    if (enable_config_groups) {
        for (const auto& [name, config] : predefined_configurations) {
            std::string suggestion1 = "use @Config " + name + ";";
            std::string suggestion2 = "use [Configuration] @Config " + name + ";";
            
            if (suggestion1.find(partial_statement) == 0) {
                suggestions.push_back(suggestion1);
            }
            if (suggestion2.find(partial_statement) == 0) {
                suggestions.push_back(suggestion2);
            }
        }
    }
    
    return suggestions;
}

// 错误处理
std::vector<std::string> UseSyntaxManager::getLastErrors() const {
    return errors;
}

std::vector<std::string> UseSyntaxManager::getLastWarnings() const {
    return warnings;
}

void UseSyntaxManager::clearErrors() {
    errors.clear();
}

void UseSyntaxManager::clearWarnings() {
    warnings.clear();
}

// 报告生成
std::string UseSyntaxManager::generateUsageReport() const {
    std::stringstream report;
    
    report << "=== CHTL Use Syntax 使用报告 ===\n\n";
    
    // HTML5声明
    if (current_html5_declaration.has_value()) {
        const auto& html5 = current_html5_declaration.value();
        report << "HTML5声明:\n";
        report << "  DOCTYPE: " << html5.doctype << "\n";
        report << "  标题: " << html5.default_title << "\n";
        report << "  Meta标签数量: " << html5.meta_tags.size() << "\n";
        report << "  响应式Meta: " << (html5.include_responsive_meta ? "是" : "否") << "\n";
        report << "  兼容性标签: " << (html5.include_compatibility_tags ? "是" : "否") << "\n\n";
    } else {
        report << "HTML5声明: 未使用\n\n";
    }
    
    // 配置组
    report << "使用的配置组 (" << used_configurations.size() << "):\n";
    for (const auto& [name, config] : used_configurations) {
        report << "  - " << name << ": " << config.description << "\n";
        report << "    配置项数量: " << config.configuration_values.size() << "\n";
    }
    report << "\n";
    
    // 当前配置
    report << "当前生效配置 (" << current_configuration.size() << "):\n";
    for (const auto& [key, value] : current_configuration) {
        report << "  " << key << " = " << value << "\n";
    }
    report << "\n";
    
    // 使用的语句
    report << "Use语句历史 (" << used_declarations.size() << "):\n";
    for (const auto& declaration : used_declarations) {
        report << "  - " << declaration.original_statement << "\n";
    }
    
    return report.str();
}

// 私有辅助方法
void UseSyntaxManager::addError(const std::string& message) const {
    errors.push_back(message);
}

void UseSyntaxManager::addWarning(const std::string& message) const {
    warnings.push_back(message);
}

std::string UseSyntaxManager::escapeJavaScriptString(const std::string& str) const {
    std::string escaped;
    for (char c : str) {
        switch (c) {
            case '"': escaped += "\\\""; break;
            case '\\': escaped += "\\\\"; break;
            case '\n': escaped += "\\n"; break;
            case '\r': escaped += "\\r"; break;
            case '\t': escaped += "\\t"; break;
            default: escaped += c; break;
        }
    }
    return escaped;
}

// ===== UseSyntaxUtils Implementation =====

UseSyntaxType UseSyntaxUtils::parseType(const std::string& use_statement) {
    std::string content = use_statement;
    
    // 移除use关键字和空格
    if (content.substr(0, 3) == "use") {
        content = content.substr(3);
        content.erase(0, content.find_first_not_of(" \t"));
    }
    
    if (content == "html5" || content.find("html5(") == 0) {
        return UseSyntaxType::HTML5_DECLARATION;
    }
    
    if (content.find("@Config") == 0) {
        return UseSyntaxType::CONFIG_GROUP;
    }
    
    if (content.find("[Configuration]") == 0) {
        return UseSyntaxType::EXPLICIT_CONFIG;
    }
    
    return UseSyntaxType::CONFIG_GROUP; // 默认
}

bool UseSyntaxUtils::isValidUseStatement(const std::string& statement) {
    // 基本格式检查
    std::regex use_pattern(R"(use\s+.+;?)");
    return std::regex_match(statement, use_pattern);
}

bool UseSyntaxUtils::isHTML5Declaration(const std::string& statement) {
    return statement.find("use html5") != std::string::npos;
}

bool UseSyntaxUtils::isConfigurationUse(const std::string& statement) {
    return statement.find("@Config") != std::string::npos;
}

std::string UseSyntaxUtils::extractConfigurationName(const std::string& statement) {
    std::regex config_pattern(R"(@Config\s+([A-Za-z_][A-Za-z0-9_]*))");
    std::smatch matches;
    
    if (std::regex_search(statement, matches, config_pattern)) {
        return matches[1].str();
    }
    
    return "";
}

std::string UseSyntaxUtils::normalizeUseStatement(const std::string& statement) {
    std::string normalized = statement;
    
    // 移除多余空格
    std::regex extra_spaces(R"(\s+)");
    normalized = std::regex_replace(normalized, extra_spaces, " ");
    
    // 去除首尾空格
    normalized.erase(0, normalized.find_first_not_of(" \t\n\r"));
    normalized.erase(normalized.find_last_not_of(" \t\n\r") + 1);
    
    // 确保以分号结尾
    if (!normalized.empty() && normalized.back() != ';') {
        normalized += ";";
    }
    
    return normalized;
}

std::vector<std::string> UseSyntaxUtils::extractUseStatements(const std::string& file_content) {
    std::vector<std::string> statements;
    
    std::regex use_pattern(R"(use\s+[^;]+;?)");
    std::sregex_iterator iter(file_content.begin(), file_content.end(), use_pattern);
    std::sregex_iterator end;
    
    for (; iter != end; ++iter) {
        statements.push_back((*iter).str());
    }
    
    return statements;
}

bool UseSyntaxUtils::validateStatementPosition(const std::vector<std::string>& file_lines, const std::string& use_statement) {
    // 查找use语句在文件中的位置
    for (size_t i = 0; i < file_lines.size(); ++i) {
        if (file_lines[i].find(use_statement) != std::string::npos) {
            // 检查之前的行是否只包含空行、注释或其他use语句
            for (size_t j = 0; j < i; ++j) {
                std::string line = file_lines[j];
                line.erase(0, line.find_first_not_of(" \t\n\r"));
                line.erase(line.find_last_not_of(" \t\n\r") + 1);
                
                if (line.empty()) continue;
                if (line.substr(0, 2) == "//" || line.substr(0, 2) == "--") continue;
                if (line.substr(0, 3) == "use") continue;
                
                return false; // 发现非允许的内容
            }
            return true;
        }
    }
    
    return false; // 未找到语句
}

// ===== UseSyntaxPatterns Implementation =====

namespace UseSyntaxPatterns {
    const std::regex HTML5_DECLARATION(R"(use\s+html5\s*(?:\([^)]*\))?\s*;?)");
    const std::regex CONFIG_GROUP_USE(R"(use\s+@Config\s+([A-Za-z_][A-Za-z0-9_]*)\s*;?)");
    const std::regex EXPLICIT_CONFIG_USE(R"(use\s+\[Configuration\]\s+@Config\s+([A-Za-z_][A-Za-z0-9_]*)\s*;?)");
    const std::regex USE_STATEMENT(R"(use\s+[^;]+\s*;?)");
}

// ===== 预定义配置 =====

namespace PredefinedConfigurations {
    const ConfigurationUse BASIC = []() {
        ConfigurationUse config;
        config.name = "Basic";
        config.type = UseSyntaxType::CONFIG_GROUP;
        config.description = "基础配置组";
        config.configuration_values = {
            {"DISABLE_STYLE_AUTO_ADD_CLASS", "false"},
            {"DISABLE_STYLE_AUTO_ADD_ID", "false"},
            {"DISABLE_SCRIPT_AUTO_ADD_CLASS", "false"},
            {"DISABLE_SCRIPT_AUTO_ADD_ID", "false"},
            {"DEFAULT_NAMESPACE", ""},
            {"STRICT_MODE", "false"}
        };
        return config;
    }();
    
    const ConfigurationUse STRICT = []() {
        ConfigurationUse config;
        config.name = "Strict";
        config.type = UseSyntaxType::CONFIG_GROUP;
        config.description = "严格模式配置组";
        config.configuration_values = {
            {"DISABLE_STYLE_AUTO_ADD_CLASS", "true"},
            {"DISABLE_STYLE_AUTO_ADD_ID", "true"},
            {"DISABLE_SCRIPT_AUTO_ADD_CLASS", "true"},
            {"DISABLE_SCRIPT_AUTO_ADD_ID", "true"},
            {"STRICT_MODE", "true"},
            {"REQUIRE_EXPLICIT_TYPES", "true"}
        };
        return config;
    }();
    
    const ConfigurationUse RESPONSIVE = []() {
        ConfigurationUse config;
        config.name = "Responsive";
        config.type = UseSyntaxType::CONFIG_GROUP;
        config.description = "响应式设计配置组";
        config.configuration_values = {
            {"ENABLE_RESPONSIVE_GRID", "true"},
            {"ENABLE_MEDIA_QUERIES", "true"},
            {"DEFAULT_BREAKPOINTS", "sm:576px,md:768px,lg:992px,xl:1200px"},
            {"ENABLE_VIEWPORT_META", "true"}
        };
        return config;
    }();
}

} // namespace CHTL
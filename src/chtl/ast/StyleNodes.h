#ifndef CHTL_STYLE_NODES_H
#define CHTL_STYLE_NODES_H

#include "ASTNode.h"
#include <unordered_map>

namespace chtl {
namespace ast {

// 样式块节点（局部样式块）
class StyleBlockNode : public ASTNode {
public:
    StyleBlockNode(const TokenLocation& location = TokenLocation())
        : ASTNode(ASTNodeType::STYLE_BLOCK, location) {}
    
    void accept(ASTVisitor& visitor) override;
    std::shared_ptr<ASTNode> clone() const override;
    
    // 添加样式规则
    void addRule(std::shared_ptr<class StyleRuleNode> rule);
    std::vector<std::shared_ptr<class StyleRuleNode>> getRules() const;
    
    // 内联样式（直接在style块中的属性）
    void addInlineProperty(std::shared_ptr<class StylePropertyNode> property);
    std::vector<std::shared_ptr<class StylePropertyNode>> getInlineProperties() const;
    
    // 获取所有需要提升到全局的规则
    std::vector<std::shared_ptr<class StyleRuleNode>> getGlobalRules() const;
};

// 样式规则节点（选择器 + 属性集）
class StyleRuleNode : public ASTNode {
public:
    StyleRuleNode(const TokenLocation& location = TokenLocation())
        : ASTNode(ASTNodeType::STYLE_RULE, location) {}
    
    void accept(ASTVisitor& visitor) override;
    std::shared_ptr<ASTNode> clone() const override;
    
    // 选择器管理
    void setSelector(std::shared_ptr<class SelectorNode> selector);
    std::shared_ptr<class SelectorNode> getSelector() const;
    
    // 属性管理
    void addProperty(std::shared_ptr<class StylePropertyNode> property);
    std::vector<std::shared_ptr<class StylePropertyNode>> getProperties() const;
    
    // 是否应该提升到全局
    bool shouldHoist() const { return hoist; }
    void setHoist(bool hoist) { this->hoist = hoist; }
    
private:
    bool hoist = false;  // 是否需要提升到全局样式块
};

// 选择器节点
class SelectorNode : public ASTNode {
public:
    enum class SelectorType {
        CLASS,           // .className
        ID,              // #id
        TAG,             // tagName
        PSEUDO_CLASS,    // :hover
        PSEUDO_ELEMENT,  // ::before
        ATTRIBUTE,       // [attr]
        UNIVERSAL,       // *
        DESCENDANT,      // 空格
        CHILD,           // >
        ADJACENT,        // +
        SIBLING,         // ~
        COMPOUND,        // 组合选择器
        REFERENCE        // & 引用选择器
    };
    
    SelectorNode(SelectorType type, const std::string& value = "",
                 const TokenLocation& location = TokenLocation())
        : ASTNode(ASTNodeType::SELECTOR, location), selectorType(type), value(value) {}
    
    void accept(ASTVisitor& visitor) override;
    std::shared_ptr<ASTNode> clone() const override;
    
    // 选择器类型和值
    SelectorType getSelectorType() const { return selectorType; }
    const std::string& getValue() const { return value; }
    void setValue(const std::string& val) { value = val; }
    
    // 复合选择器支持
    void addPart(std::shared_ptr<SelectorNode> part);
    std::vector<std::shared_ptr<SelectorNode>> getParts() const;
    
    // 生成选择器字符串
    std::string toString() const override;
    
    // 自动化支持
    bool isAutoGenerated() const { return autoGenerated; }
    void setAutoGenerated(bool auto_) { autoGenerated = auto_; }
    
private:
    SelectorType selectorType;
    std::string value;
    bool autoGenerated = false;  // 是否是自动生成的选择器
};

// 样式属性节点
class StylePropertyNode : public ASTNode {
public:
    StylePropertyNode(const std::string& name, const std::string& value,
                      const TokenLocation& location = TokenLocation())
        : ASTNode(ASTNodeType::STYLE_PROPERTY, location), name(name), value(value) {}
    
    void accept(ASTVisitor& visitor) override;
    std::shared_ptr<ASTNode> clone() const override;
    
    const std::string& getName() const { return name; }
    const std::string& getValue() const { return value; }
    void setValue(const std::string& val) { value = val; }
    
    // 是否重要
    bool isImportant() const { return important; }
    void setImportant(bool imp) { important = imp; }
    
    // 是否使用变量
    bool hasVariable() const { return !variableName.empty(); }
    const std::string& getVariableName() const { return variableName; }
    void setVariableName(const std::string& var) { variableName = var; }
    
private:
    std::string name;
    std::string value;
    bool important = false;
    std::string variableName;  // 如果值是变量引用
};

// 样式组节点（模板或自定义样式组）
class StyleGroupNode : public ASTNode {
public:
    enum class GroupType {
        TEMPLATE,    // [Template] @Style
        CUSTOM,      // [Custom] @Style
        REFERENCE    // 引用的样式组
    };
    
    StyleGroupNode(GroupType type, const std::string& name,
                   const TokenLocation& location = TokenLocation())
        : ASTNode(type == GroupType::TEMPLATE ? ASTNodeType::TEMPLATE : ASTNodeType::CUSTOM, location),
          groupType(type), name(name) {}
    
    void accept(ASTVisitor& visitor) override;
    std::shared_ptr<ASTNode> clone() const override;
    
    // 基本属性
    GroupType getGroupType() const { return groupType; }
    const std::string& getName() const { return name; }
    
    // 属性管理
    void addProperty(std::shared_ptr<StylePropertyNode> property);
    std::vector<std::shared_ptr<StylePropertyNode>> getProperties() const;
    
    // 无值属性（自定义样式组特有）
    void addValuelessProperty(const std::string& name);
    std::vector<std::string> getValuelessProperties() const { return valuelessProperties; }
    bool hasValuelessProperties() const { return !valuelessProperties.empty(); }
    
    // 继承管理
    void addInheritance(std::shared_ptr<class ReferenceNode> ref);
    std::vector<std::shared_ptr<class ReferenceNode>> getInheritances() const;
    
    // 删除操作（自定义样式组特有）
    void addDeleteProperty(const std::string& propName);
    void addDeleteInheritance(const std::string& refName);
    std::vector<std::string> getDeletedProperties() const { return deletedProperties; }
    std::vector<std::string> getDeletedInheritances() const { return deletedInheritances; }
    
private:
    GroupType groupType;
    std::string name;
    std::vector<std::string> valuelessProperties;  // 无值属性列表
    std::vector<std::string> deletedProperties;    // 要删除的属性
    std::vector<std::string> deletedInheritances;  // 要删除的继承
};

// 扩展访问者接口
class ASTVisitor {
public:
    virtual void visit(StyleBlockNode& node) = 0;
    virtual void visit(StyleRuleNode& node) = 0;
    virtual void visit(SelectorNode& node) = 0;
    virtual void visit(StylePropertyNode& node) = 0;
    virtual void visit(StyleGroupNode& node) = 0;
};

} // namespace ast
} // namespace chtl

#endif // CHTL_STYLE_NODES_H
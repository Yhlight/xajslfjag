#pragma once
#include "../CHTLNode/BaseNode.h"
#include "../CHTLNode/ElementNode.h"
#include "../CHTLNode/StyleNode.h"
#include "../CHTLNode/ScriptNode.h"
#include "../CHTLNode/ConfigNode.h"
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>

namespace CHTL {

/**
 * 自动化选择器类型
 */
enum class AutomationSelectorType {
    CLASS_SELECTOR,    // 类选择器 .className
    ID_SELECTOR,       // ID选择器 #idName
    REFERENCE_SELECTOR // 引用选择器 &
};

/**
 * 自动化规则
 */
struct AutomationRule {
    bool enableStyleAutoClass = true;     // 样式自动添加类选择器
    bool enableStyleAutoId = true;        // 样式自动添加ID选择器
    bool enableScriptAutoClass = false;   // 脚本自动添加类选择器
    bool enableScriptAutoId = false;      // 脚本自动添加ID选择器
    int maxAutoSelectors = 10;             // 最大自动选择器数量
    
    /**
     * 从配置节点加载规则
     */
    void loadFromConfig(const ConfigurationNode* configNode);
};

/**
 * 选择器信息
 */
struct SelectorInfo {
    AutomationSelectorType type;           // 选择器类型
    std::string name;            // 选择器名称
    std::string context;         // 上下文信息
    bool isAutoGenerated;        // 是否自动生成
    
    SelectorInfo() : type(AutomationSelectorType::CLASS_SELECTOR), isAutoGenerated(false) {}
    
    SelectorInfo(AutomationSelectorType t, const std::string& n, bool autoGen = false)
        : type(t), name(n), isAutoGenerated(autoGen) {}
    
    /**
     * 转换为CSS选择器字符串
     */
    std::string toCSSSelector() const;
    
    /**
     * 转换为CHTL JS选择器字符串
     */
    std::string toCHTLJSSelector() const;
};

/**
 * 自动化上下文
 */
class AutomationContext {
public:
    /**
     * 构造函数
     */
    AutomationContext(std::shared_ptr<ElementNode> element);
    
    /**
     * 析构函数
     */
    ~AutomationContext() = default;
    
    /**
     * 获取关联的元素节点
     */
    std::shared_ptr<ElementNode> getElement() const;
    
    /**
     * 添加选择器
     */
    void addSelector(const SelectorInfo& selector);
    
    /**
     * 获取所有选择器
     */
    const std::vector<SelectorInfo>& getSelectors() const;
    
    /**
     * 获取类选择器
     */
    std::vector<SelectorInfo> getClassSelectors() const;
    
    /**
     * 获取ID选择器
     */
    std::vector<SelectorInfo> getIdSelectors() const;
    
    /**
     * 获取第一个类选择器
     */
    SelectorInfo getFirstClassSelector() const;
    
    /**
     * 获取第一个ID选择器
     */
    SelectorInfo getFirstIdSelector() const;
    
    /**
     * 检查是否有类选择器
     */
    bool hasClassSelector() const;
    
    /**
     * 检查是否有ID选择器
     */
    bool hasIdSelector() const;
    
    /**
     * 清除所有选择器
     */
    void clearSelectors();

private:
    std::shared_ptr<ElementNode> m_element;     // 关联的元素节点
    std::vector<SelectorInfo> m_selectors;      // 选择器列表
};

/**
 * 选择器自动化管理器
 * 负责处理CHTL的选择器自动化规则和引用规则
 */
class SelectorAutomationManager {
public:
    /**
     * 构造函数
     */
    SelectorAutomationManager();
    
    /**
     * 析构函数
     */
    ~SelectorAutomationManager() = default;
    
    /**
     * 设置自动化规则
     */
    void setAutomationRules(const AutomationRule& rules);
    
    /**
     * 获取自动化规则
     */
    const AutomationRule& getAutomationRules() const;
    
    /**
     * 处理元素的样式自动化
     */
    void processStyleAutomation(std::shared_ptr<ElementNode> element);
    
    /**
     * 处理元素的脚本自动化
     */
    void processScriptAutomation(std::shared_ptr<ElementNode> element);
    
    /**
     * 解析样式块中的选择器
     */
    std::vector<SelectorInfo> parseStyleSelectors(std::shared_ptr<StyleNode> styleNode);
    
    /**
     * 解析脚本块中的选择器
     */
    std::vector<SelectorInfo> parseScriptSelectors(std::shared_ptr<ScriptNode> scriptNode);
    
    /**
     * 应用类选择器自动化
     */
    void applyClassAutomation(std::shared_ptr<ElementNode> element, const std::vector<SelectorInfo>& selectors);
    
    /**
     * 应用ID选择器自动化
     */
    void applyIdAutomation(std::shared_ptr<ElementNode> element, const std::vector<SelectorInfo>& selectors);
    
    /**
     * 解析引用选择器
     */
    std::string resolveReferenceSelector(std::shared_ptr<ElementNode> element, const std::string& context = "style");
    
    /**
     * 获取元素的自动化上下文
     */
    AutomationContext* getAutomationContext(std::shared_ptr<ElementNode> element);
    
    /**
     * 创建自动化上下文
     */
    AutomationContext* createAutomationContext(std::shared_ptr<ElementNode> element);
    
    /**
     * 清除自动化上下文
     */
    void clearAutomationContext(std::shared_ptr<ElementNode> element);
    
    /**
     * 清除所有自动化上下文
     */
    void clearAllAutomationContexts();
    
    /**
     * 生成自动化报告
     */
    std::string generateAutomationReport() const;
    
    /**
     * 验证选择器的有效性
     */
    bool validateSelector(const SelectorInfo& selector) const;
    
    /**
     * 规范化选择器名称
     */
    std::string normalizeSelector(const std::string& selectorName) const;

private:
    AutomationRule m_automationRules;                                      // 自动化规则
    std::unordered_map<ElementNode*, std::unique_ptr<AutomationContext>> m_automationContexts; // 自动化上下文映射
    std::unordered_set<std::string> m_usedClassNames;                     // 已使用的类名
    std::unordered_set<std::string> m_usedIdNames;                        // 已使用的ID名
    
    /**
     * 解析CSS选择器字符串
     */
    std::vector<SelectorInfo> parseCSSSelectors(const std::string& cssContent);
    
    /**
     * 解析CHTL JS选择器字符串
     */
    std::vector<SelectorInfo> parseCHTLJSSelectors(const std::string& jsContent);
    
    /**
     * 提取类选择器
     */
    std::vector<std::string> extractClassSelectors(const std::string& content);
    
    /**
     * 提取ID选择器
     */
    std::vector<std::string> extractIdSelectors(const std::string& content);
    
    /**
     * 提取引用选择器
     */
    std::vector<std::string> extractReferenceSelectors(const std::string& content);
    
    /**
     * 生成唯一的类名
     */
    std::string generateUniqueClassName(const std::string& baseName);
    
    /**
     * 生成唯一的ID名
     */
    std::string generateUniqueIdName(const std::string& baseName);
    
    /**
     * 检查选择器名称是否有效
     */
    bool isValidSelectorName(const std::string& name) const;
    
    /**
     * 应用选择器到元素属性
     */
    void applySelectorToElement(std::shared_ptr<ElementNode> element, const SelectorInfo& selector);
};

/**
 * 引用规则处理器
 * 专门处理&引用选择器的解析和替换
 */
class ReferenceRuleProcessor {
public:
    /**
     * 构造函数
     */
    ReferenceRuleProcessor(SelectorAutomationManager* manager);
    
    /**
     * 析构函数
     */
    ~ReferenceRuleProcessor() = default;
    
    /**
     * 处理样式块中的引用
     */
    std::string processStyleReferences(std::shared_ptr<ElementNode> element, const std::string& styleContent);
    
    /**
     * 处理脚本块中的引用
     */
    std::string processScriptReferences(std::shared_ptr<ElementNode> element, const std::string& scriptContent);
    
    /**
     * 解析&引用
     */
    std::string resolveReference(std::shared_ptr<ElementNode> element, const std::string& context);
    
    /**
     * 替换引用选择器
     */
    std::string replaceReferences(const std::string& content, const std::string& replacement);
    
    /**
     * 设置引用优先级
     * 对于样式：优先选择类名
     * 对于脚本：优先选择ID
     */
    void setReferencePriority(const std::string& context, AutomationSelectorType priority);
    
    /**
     * 获取引用优先级
     */
    AutomationSelectorType getReferencePriority(const std::string& context) const;

private:
    SelectorAutomationManager* m_automationManager;                // 自动化管理器
    std::unordered_map<std::string, AutomationSelectorType> m_priorities;    // 上下文优先级映射
    
    /**
     * 查找引用模式
     */
    std::vector<size_t> findReferencePositions(const std::string& content);
    
    /**
     * 验证引用上下文
     */
    bool isValidReferenceContext(const std::string& content, size_t position) const;
};

} // namespace CHTL
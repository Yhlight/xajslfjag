#pragma once

#include "BaseNode.h"
#include <unordered_set>

namespace CHTL {

/// CSS选择器类型
enum class SelectorType {
    ELEMENT,        // 元素选择器 div
    CLASS,          // 类选择器 .class
    ID,             // ID选择器 #id
    PSEUDO_CLASS,   // 伪类选择器 :hover
    PSEUDO_ELEMENT, // 伪元素选择器 ::before
    CONTEXT_REF,    // 上下文引用 &
    DESCENDANT,     // 后代选择器 .parent .child
    CHILD,          // 子元素选择器 .parent > .child
    UNIVERSAL       // 通用选择器 *
};

/// CSS选择器节点
class SelectorNode : public BaseNode {
private:
    SelectorType selectorType;
    std::string selectorValue;  // 选择器值
    bool isAutoGenerated;       // 是否为自动生成的选择器

public:
    SelectorNode(SelectorType type, const std::string& value, const NodePosition& pos = NodePosition());
    
    /// 获取选择器类型
    SelectorType GetSelectorType() const { return selectorType; }
    
    /// 获取选择器值
    const std::string& GetSelectorValue() const { return selectorValue; }
    
    /// 设置选择器值
    void SetSelectorValue(const std::string& value) { selectorValue = value; }
    
    /// 设置是否为自动生成
    void SetAutoGenerated(bool autoGen) { isAutoGenerated = autoGen; }
    
    /// 检查是否为自动生成
    bool IsAutoGenerated() const { return isAutoGenerated; }
    
    /// 转换为CSS选择器字符串
    std::string ToCssSelector() const;
    
    /// 克隆节点
    std::shared_ptr<BaseNode> Clone() const override;
    
    /// 验证节点
    bool Validate() const override;
    
    /// 获取节点描述
    std::string GetDescription() const override;
    
    /// 接受访问者
    void Accept(NodeVisitor& visitor) override;
};

/// CSS属性节点
class StylePropertyNode : public BaseNode {
private:
    std::string propertyName;   // 属性名
    std::string propertyValue;  // 属性值
    bool isImportant;          // 是否有!important

public:
    StylePropertyNode(const std::string& name, const std::string& value, const NodePosition& pos = NodePosition());
    
    /// 获取属性名
    const std::string& GetPropertyName() const { return propertyName; }
    
    /// 获取属性值
    const std::string& GetPropertyValue() const { return propertyValue; }
    
    /// 设置属性名
    void SetPropertyName(const std::string& name) { propertyName = name; }
    
    /// 设置属性值
    void SetPropertyValue(const std::string& value) { propertyValue = value; }
    
    /// 设置important标记
    void SetImportant(bool important) { isImportant = important; }
    
    /// 检查是否有important标记
    bool IsImportant() const { return isImportant; }
    
    /// 转换为CSS属性字符串
    std::string ToCssProperty() const;
    
    /// 克隆节点
    std::shared_ptr<BaseNode> Clone() const override;
    
    /// 验证节点
    bool Validate() const override;
    
    /// 获取节点描述
    std::string GetDescription() const override;
    
    /// 接受访问者
    void Accept(NodeVisitor& visitor) override;
};

/// CSS规则节点（选择器+属性组合）
class StyleRuleNode : public BaseNode {
private:
    std::vector<std::shared_ptr<SelectorNode>> selectors;  // 选择器列表
    bool isInlineStyle;  // 是否为内联样式

public:
    StyleRuleNode(const NodePosition& pos = NodePosition());
    
    /// 添加选择器
    void AddSelector(std::shared_ptr<SelectorNode> selector);
    
    /// 获取选择器列表
    const std::vector<std::shared_ptr<SelectorNode>>& GetSelectors() const { return selectors; }
    
    /// 添加样式属性
    void AddProperty(std::shared_ptr<StylePropertyNode> property);
    
    /// 获取样式属性列表
    std::vector<std::shared_ptr<StylePropertyNode>> GetProperties() const;
    
    /// 设置是否为内联样式
    void SetInlineStyle(bool inline_style) { isInlineStyle = inline_style; }
    
    /// 检查是否为内联样式
    bool IsInlineStyle() const { return isInlineStyle; }
    
    /// 转换为CSS规则字符串
    std::string ToCssRule() const;
    
    /// 克隆节点
    std::shared_ptr<BaseNode> Clone() const override;
    
    /// 验证节点
    bool Validate() const override;
    
    /// 获取节点描述
    std::string GetDescription() const override;
    
    /// 接受访问者
    void Accept(NodeVisitor& visitor) override;
};

/// 样式块节点 - style { }
class StyleBlockNode : public BaseNode {
private:
    std::unordered_set<std::string> autoGeneratedClasses;  // 自动生成的类名
    std::unordered_set<std::string> autoGeneratedIds;      // 自动生成的ID
    bool hasContextReference;  // 是否包含&引用

public:
    StyleBlockNode(const NodePosition& pos = NodePosition());
    
    /// 添加样式规则
    void AddStyleRule(std::shared_ptr<StyleRuleNode> rule);
    
    /// 获取样式规则列表
    std::vector<std::shared_ptr<StyleRuleNode>> GetStyleRules() const;
    
    /// 添加内联样式属性
    void AddInlineProperty(std::shared_ptr<StylePropertyNode> property);
    
    /// 获取内联样式属性列表
    std::vector<std::shared_ptr<StylePropertyNode>> GetInlineProperties() const;
    
    /// 记录自动生成的类名
    void AddAutoGeneratedClass(const std::string& className);
    
    /// 记录自动生成的ID
    void AddAutoGeneratedId(const std::string& id);
    
    /// 获取自动生成的类名集合
    const std::unordered_set<std::string>& GetAutoGeneratedClasses() const { return autoGeneratedClasses; }
    
    /// 获取自动生成的ID集合
    const std::unordered_set<std::string>& GetAutoGeneratedIds() const { return autoGeneratedIds; }
    
    /// 设置是否包含上下文引用
    void SetHasContextReference(bool hasRef) { hasContextReference = hasRef; }
    
    /// 检查是否包含上下文引用
    bool HasContextReference() const { return hasContextReference; }
    
    /// 解析选择器中的自动化规则
    void ProcessAutomaticSelectors();
    
    /// 生成内联样式字符串
    std::string GenerateInlineStyles() const;
    
    /// 生成全局CSS规则字符串
    std::string GenerateGlobalCss() const;
    
    /// 克隆节点
    std::shared_ptr<BaseNode> Clone() const override;
    
    /// 验证节点
    bool Validate() const override;
    
    /// 获取节点描述
    std::string GetDescription() const override;
    
    /// 接受访问者
    void Accept(NodeVisitor& visitor) override;
};

/// 选择器类型转换为字符串
std::string SelectorTypeToString(SelectorType type);

/// 选择器工厂类
class SelectorFactory {
public:
    /// 创建类选择器
    static std::shared_ptr<SelectorNode> CreateClassSelector(const std::string& className, const NodePosition& pos = NodePosition());
    
    /// 创建ID选择器
    static std::shared_ptr<SelectorNode> CreateIdSelector(const std::string& id, const NodePosition& pos = NodePosition());
    
    /// 创建元素选择器
    static std::shared_ptr<SelectorNode> CreateElementSelector(const std::string& element, const NodePosition& pos = NodePosition());
    
    /// 创建伪类选择器
    static std::shared_ptr<SelectorNode> CreatePseudoClassSelector(const std::string& pseudoClass, const NodePosition& pos = NodePosition());
    
    /// 创建伪元素选择器
    static std::shared_ptr<SelectorNode> CreatePseudoElementSelector(const std::string& pseudoElement, const NodePosition& pos = NodePosition());
    
    /// 创建上下文引用选择器
    static std::shared_ptr<SelectorNode> CreateContextRefSelector(const NodePosition& pos = NodePosition());
};

} // namespace CHTL
#include "StyleNode.h"
#include "NodeVisitor.h"
#include <sstream>
#include <algorithm>

namespace CHTL {

// SelectorNode实现

SelectorNode::SelectorNode(SelectorType type, const std::string& value, const NodePosition& pos)
    : BaseNode(NodeType::STYLE_PROPERTY, pos), selectorType(type), selectorValue(value), isAutoGenerated(false) {
}

std::string SelectorNode::ToCssSelector() const {
    switch (selectorType) {
        case SelectorType::ELEMENT:
            return selectorValue;
        case SelectorType::CLASS:
            return "." + selectorValue;
        case SelectorType::ID:
            return "#" + selectorValue;
        case SelectorType::PSEUDO_CLASS:
            return ":" + selectorValue;
        case SelectorType::PSEUDO_ELEMENT:
            return "::" + selectorValue;
        case SelectorType::CONTEXT_REF:
            return "&"; // 在生成时会被替换
        case SelectorType::UNIVERSAL:
            return "*";
        default:
            return selectorValue;
    }
}

std::shared_ptr<BaseNode> SelectorNode::Clone() const {
    auto cloned = std::make_shared<SelectorNode>(selectorType, selectorValue, position);
    cloned->isAutoGenerated = isAutoGenerated;
    cloned->metadata = metadata;
    return cloned;
}

bool SelectorNode::Validate() const {
    // 选择器值不能为空（除了通用选择器和上下文引用）
    if (selectorType != SelectorType::UNIVERSAL && 
        selectorType != SelectorType::CONTEXT_REF && 
        selectorValue.empty()) {
        return false;
    }
    
    return BaseNode::Validate();
}

std::string SelectorNode::GetDescription() const {
    std::ostringstream oss;
    oss << "Selector(" << SelectorTypeToString(selectorType) << ")";
    if (!selectorValue.empty()) {
        oss << "[" << selectorValue << "]";
    }
    if (isAutoGenerated) {
        oss << "(auto)";
    }
    oss << " at (" << position.line << ":" << position.column << ")";
    return oss.str();
}

void SelectorNode::Accept(NodeVisitor& visitor) {
    // SelectorNode作为样式系统的一部分，通过StyleBlockNode访问
}

// StylePropertyNode实现

StylePropertyNode::StylePropertyNode(const std::string& name, const std::string& value, const NodePosition& pos)
    : BaseNode(NodeType::STYLE_PROPERTY, pos), propertyName(name), propertyValue(value), isImportant(false) {
}

std::string StylePropertyNode::ToCssProperty() const {
    std::string result = propertyName + ": " + propertyValue;
    if (isImportant) {
        result += " !important";
    }
    result += ";";
    return result;
}

std::shared_ptr<BaseNode> StylePropertyNode::Clone() const {
    auto cloned = std::make_shared<StylePropertyNode>(propertyName, propertyValue, position);
    cloned->isImportant = isImportant;
    cloned->metadata = metadata;
    return cloned;
}

bool StylePropertyNode::Validate() const {
    // 属性名和属性值都不能为空
    if (propertyName.empty() || propertyValue.empty()) {
        return false;
    }
    
    return BaseNode::Validate();
}

std::string StylePropertyNode::GetDescription() const {
    std::ostringstream oss;
    oss << "StyleProperty[" << propertyName << ": " << propertyValue;
    if (isImportant) {
        oss << " !important";
    }
    oss << "] at (" << position.line << ":" << position.column << ")";
    return oss.str();
}

void StylePropertyNode::Accept(NodeVisitor& visitor) {
    // StylePropertyNode作为样式系统的一部分，通过StyleBlockNode访问
}

// StyleRuleNode实现

StyleRuleNode::StyleRuleNode(const NodePosition& pos)
    : BaseNode(NodeType::STYLE_BLOCK, pos), isInlineStyle(false) {
}

void StyleRuleNode::AddSelector(std::shared_ptr<SelectorNode> selector) {
    if (selector) {
        selectors.push_back(selector);
    }
}

void StyleRuleNode::AddProperty(std::shared_ptr<StylePropertyNode> property) {
    if (property) {
        AddChild(property);
    }
}

std::vector<std::shared_ptr<StylePropertyNode>> StyleRuleNode::GetProperties() const {
    std::vector<std::shared_ptr<StylePropertyNode>> properties;
    for (const auto& child : children) {
        if (child->GetNodeType() == NodeType::STYLE_PROPERTY) {
            properties.push_back(std::static_pointer_cast<StylePropertyNode>(child));
        }
    }
    return properties;
}

std::string StyleRuleNode::ToCssRule() const {
    if (isInlineStyle) {
        // 内联样式只输出属性
        std::ostringstream oss;
        auto properties = GetProperties();
        for (size_t i = 0; i < properties.size(); ++i) {
            if (i > 0) oss << " ";
            oss << properties[i]->ToCssProperty();
        }
        return oss.str();
    } else {
        // 完整的CSS规则
        std::ostringstream oss;
        
        // 输出选择器
        for (size_t i = 0; i < selectors.size(); ++i) {
            if (i > 0) oss << ", ";
            oss << selectors[i]->ToCssSelector();
        }
        
        oss << " {\n";
        
        // 输出属性
        auto properties = GetProperties();
        for (const auto& property : properties) {
            oss << "    " << property->ToCssProperty() << "\n";
        }
        
        oss << "}";
        return oss.str();
    }
}

std::shared_ptr<BaseNode> StyleRuleNode::Clone() const {
    auto cloned = std::make_shared<StyleRuleNode>(position);
    cloned->isInlineStyle = isInlineStyle;
    cloned->metadata = metadata;
    
    // 克隆选择器
    for (const auto& selector : selectors) {
        cloned->selectors.push_back(std::static_pointer_cast<SelectorNode>(selector->Clone()));
    }
    
    // 克隆子节点（属性）
    for (const auto& child : children) {
        cloned->AddChild(child->Clone());
    }
    
    return cloned;
}

bool StyleRuleNode::Validate() const {
    // 非内联样式必须有选择器
    if (!isInlineStyle && selectors.empty()) {
        return false;
    }
    
    return BaseNode::Validate();
}

std::string StyleRuleNode::GetDescription() const {
    std::ostringstream oss;
    oss << "StyleRule";
    if (isInlineStyle) {
        oss << "(inline)";
    }
    oss << "[" << selectors.size() << " selectors, " << GetProperties().size() << " properties]";
    oss << " at (" << position.line << ":" << position.column << ")";
    return oss.str();
}

void StyleRuleNode::Accept(NodeVisitor& visitor) {
    // StyleRuleNode作为样式系统的一部分，通过StyleBlockNode访问
}

// StyleBlockNode实现

StyleBlockNode::StyleBlockNode(const NodePosition& pos)
    : BaseNode(NodeType::STYLE_BLOCK, pos), hasContextReference(false) {
}

void StyleBlockNode::AddStyleRule(std::shared_ptr<StyleRuleNode> rule) {
    if (rule) {
        AddChild(rule);
    }
}

std::vector<std::shared_ptr<StyleRuleNode>> StyleBlockNode::GetStyleRules() const {
    std::vector<std::shared_ptr<StyleRuleNode>> rules;
    for (const auto& child : children) {
        if (child->GetNodeType() == NodeType::STYLE_BLOCK) {
            rules.push_back(std::static_pointer_cast<StyleRuleNode>(child));
        }
    }
    return rules;
}

void StyleBlockNode::AddInlineProperty(std::shared_ptr<StylePropertyNode> property) {
    if (property) {
        AddChild(property);
    }
}

std::vector<std::shared_ptr<StylePropertyNode>> StyleBlockNode::GetInlineProperties() const {
    std::vector<std::shared_ptr<StylePropertyNode>> properties;
    for (const auto& child : children) {
        if (child->GetNodeType() == NodeType::STYLE_PROPERTY) {
            properties.push_back(std::static_pointer_cast<StylePropertyNode>(child));
        }
    }
    return properties;
}

void StyleBlockNode::AddAutoGeneratedClass(const std::string& className) {
    autoGeneratedClasses.insert(className);
}

void StyleBlockNode::AddAutoGeneratedId(const std::string& id) {
    autoGeneratedIds.insert(id);
}

void StyleBlockNode::ProcessAutomaticSelectors() {
    // 处理自动化选择器生成
    auto rules = GetStyleRules();
    for (const auto& rule : rules) {
        for (const auto& selector : rule->GetSelectors()) {
            if (selector->GetSelectorType() == SelectorType::CLASS) {
                AddAutoGeneratedClass(selector->GetSelectorValue());
                selector->SetAutoGenerated(true);
            } else if (selector->GetSelectorType() == SelectorType::ID) {
                AddAutoGeneratedId(selector->GetSelectorValue());
                selector->SetAutoGenerated(true);
            } else if (selector->GetSelectorType() == SelectorType::CONTEXT_REF) {
                hasContextReference = true;
            }
        }
    }
}

std::string StyleBlockNode::GenerateInlineStyles() const {
    std::ostringstream oss;
    auto properties = GetInlineProperties();
    
    for (size_t i = 0; i < properties.size(); ++i) {
        if (i > 0) oss << " ";
        oss << properties[i]->GetPropertyName() << ": " << properties[i]->GetPropertyValue() << ";";
    }
    
    return oss.str();
}

std::string StyleBlockNode::GenerateGlobalCss() const {
    std::ostringstream oss;
    auto rules = GetStyleRules();
    
    for (const auto& rule : rules) {
        if (!rule->IsInlineStyle()) {
            oss << rule->ToCssRule() << "\n\n";
        }
    }
    
    return oss.str();
}

std::shared_ptr<BaseNode> StyleBlockNode::Clone() const {
    auto cloned = std::make_shared<StyleBlockNode>(position);
    cloned->autoGeneratedClasses = autoGeneratedClasses;
    cloned->autoGeneratedIds = autoGeneratedIds;
    cloned->hasContextReference = hasContextReference;
    cloned->metadata = metadata;
    
    // 克隆子节点
    for (const auto& child : children) {
        cloned->AddChild(child->Clone());
    }
    
    return cloned;
}

bool StyleBlockNode::Validate() const {
    // 验证所有子节点都是样式相关的
    for (const auto& child : children) {
        if (child->GetNodeType() != NodeType::STYLE_PROPERTY && 
            child->GetNodeType() != NodeType::STYLE_BLOCK) {
            return false;
        }
    }
    
    return BaseNode::Validate();
}

std::string StyleBlockNode::GetDescription() const {
    std::ostringstream oss;
    oss << "StyleBlock[" << GetStyleRules().size() << " rules, " << GetInlineProperties().size() << " inline props]";
    if (hasContextReference) {
        oss << "(has &)";
    }
    oss << " at (" << position.line << ":" << position.column << ")";
    return oss.str();
}

void StyleBlockNode::Accept(NodeVisitor& visitor) {
    visitor.VisitStyleBlock(*this);
}

// 辅助函数

std::string SelectorTypeToString(SelectorType type) {
    switch (type) {
        case SelectorType::ELEMENT: return "ELEMENT";
        case SelectorType::CLASS: return "CLASS";
        case SelectorType::ID: return "ID";
        case SelectorType::PSEUDO_CLASS: return "PSEUDO_CLASS";
        case SelectorType::PSEUDO_ELEMENT: return "PSEUDO_ELEMENT";
        case SelectorType::CONTEXT_REF: return "CONTEXT_REF";
        case SelectorType::DESCENDANT: return "DESCENDANT";
        case SelectorType::CHILD: return "CHILD";
        case SelectorType::UNIVERSAL: return "UNIVERSAL";
        default: return "UNKNOWN";
    }
}

// SelectorFactory实现

std::shared_ptr<SelectorNode> SelectorFactory::CreateClassSelector(const std::string& className, const NodePosition& pos) {
    return std::make_shared<SelectorNode>(SelectorType::CLASS, className, pos);
}

std::shared_ptr<SelectorNode> SelectorFactory::CreateIdSelector(const std::string& id, const NodePosition& pos) {
    return std::make_shared<SelectorNode>(SelectorType::ID, id, pos);
}

std::shared_ptr<SelectorNode> SelectorFactory::CreateElementSelector(const std::string& element, const NodePosition& pos) {
    return std::make_shared<SelectorNode>(SelectorType::ELEMENT, element, pos);
}

std::shared_ptr<SelectorNode> SelectorFactory::CreatePseudoClassSelector(const std::string& pseudoClass, const NodePosition& pos) {
    return std::make_shared<SelectorNode>(SelectorType::PSEUDO_CLASS, pseudoClass, pos);
}

std::shared_ptr<SelectorNode> SelectorFactory::CreatePseudoElementSelector(const std::string& pseudoElement, const NodePosition& pos) {
    return std::make_shared<SelectorNode>(SelectorType::PSEUDO_ELEMENT, pseudoElement, pos);
}

std::shared_ptr<SelectorNode> SelectorFactory::CreateContextRefSelector(const NodePosition& pos) {
    return std::make_shared<SelectorNode>(SelectorType::CONTEXT_REF, "&", pos);
}

} // namespace CHTL
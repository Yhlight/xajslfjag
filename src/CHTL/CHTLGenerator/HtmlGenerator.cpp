#include "HtmlGenerator.h"
#include <algorithm>
#include <regex>

namespace CHTL {

// HtmlGenerator实现

HtmlGenerator::HtmlGenerator(const HtmlGenerationOptions& opts)
    : options(opts), indentLevel(0), isInlineContext(false) {
}

HtmlGenerationResult HtmlGenerator::Generate(std::shared_ptr<BaseNode> rootNode) {
    ResetState();
    
    if (!rootNode) {
        AddError("根节点为空");
        return CreateResult();
    }
    
    // 查找HTML根元素或创建默认结构
    auto htmlRoot = FindHtmlRoot(rootNode);
    if (htmlRoot) {
        // 如果找到HTML元素，直接遍历
        rootNode->Accept(*this);
    } else {
        // 如果没有HTML元素，创建标准HTML文档结构
        GenerateHtmlDocument(rootNode);
    }
    
    return CreateResult();
}

void HtmlGenerator::VisitElement(ElementNode& node) {
    // 检查是否需要应用自动生成的标识符
    ApplyAutomaticIdentifiers(node);
    
    // 生成开始标签
    GenerateElementStart(node);
    
    if (!node.IsSelfClosing()) {
        // 处理子节点
        bool hasNonTextChildren = false;
        for (const auto& child : node.GetChildren()) {
            if (child->GetNodeType() != NodeType::TEXT) {
                hasNonTextChildren = true;
                break;
            }
        }
        
        if (hasNonTextChildren && options.prettyPrint) {
            WriteNewline();
            IncreaseIndent();
        }
        
        // 访问子节点
        for (const auto& child : node.GetChildren()) {
            child->Accept(*this);
        }
        
        if (hasNonTextChildren && options.prettyPrint) {
            DecreaseIndent();
            WriteIndent();
        }
        
        // 生成结束标签
        GenerateElementEnd(node);
    }
    
    if (options.prettyPrint && !isInlineContext) {
        WriteNewline();
    }
}

void HtmlGenerator::VisitText(TextNode& node) {
    GenerateTextContent(node.GetProcessedContent());
}

void HtmlGenerator::VisitComment(CommentNode& node) {
    GenerateComment(node);
}

void HtmlGenerator::VisitStyleBlock(StyleBlockNode& node) {
    ProcessStyleBlock(node);
}

void HtmlGenerator::VisitScriptBlock(ScriptBlockNode& node) {
    ProcessScriptBlock(node);
}

// === 私有方法实现 ===

void HtmlGenerator::WriteIndent() {
    if (options.prettyPrint) {
        for (int i = 0; i < indentLevel; ++i) {
            htmlStream << options.indentString;
        }
    }
}

void HtmlGenerator::WriteNewline() {
    if (options.prettyPrint) {
        htmlStream << "\n";
    }
}

void HtmlGenerator::WriteHtml(const std::string& content) {
    htmlStream << content;
}

void HtmlGenerator::WriteCss(const std::string& content) {
    cssStream << content;
}

void HtmlGenerator::WriteJs(const std::string& content) {
    jsStream << content;
}

void HtmlGenerator::GenerateHtmlDocument(std::shared_ptr<BaseNode> rootNode) {
    // 生成DOCTYPE
    if (options.generateDoctype) {
        WriteHtml("<!DOCTYPE html>");
        WriteNewline();
    }
    
    // 生成HTML开始标签
    WriteHtml("<html");
    if (!options.language.empty()) {
        WriteHtml(" lang=\"" + EscapeAttribute(options.language) + "\"");
    }
    WriteHtml(">");
    WriteNewline();
    
    IncreaseIndent();
    
    // 生成Head部分
    GenerateHtmlHead();
    
    // 生成Body部分
    auto bodyContent = ExtractBodyContent(rootNode);
    GenerateHtmlBody(bodyContent);
    
    DecreaseIndent();
    
    // 生成HTML结束标签
    WriteHtml("</html>");
    WriteNewline();
}

void HtmlGenerator::GenerateHtmlHead() {
    WriteIndent();
    WriteHtml("<head>");
    WriteNewline();
    
    IncreaseIndent();
    
    // 生成基础meta标签
    WriteIndent();
    WriteHtml("<meta charset=\"" + EscapeAttribute(options.charset) + "\">");
    WriteNewline();
    
    WriteIndent();
    WriteHtml("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">");
    WriteNewline();
    
    WriteIndent();
    WriteHtml("<title>CHTL编译结果</title>");
    WriteNewline();
    
    // 如果有CSS内容，生成style标签
    if (!cssStream.str().empty() || !autoGeneratedClasses.empty() || !autoGeneratedIds.empty()) {
        WriteIndent();
        WriteHtml("<style>");
        WriteNewline();
        
        // 写入CSS内容
        std::string cssContent = cssStream.str();
        if (!cssContent.empty()) {
            WriteHtml(cssContent);
        }
        
        WriteIndent();
        WriteHtml("</style>");
        WriteNewline();
    }
    
    DecreaseIndent();
    
    WriteIndent();
    WriteHtml("</head>");
    WriteNewline();
}

void HtmlGenerator::GenerateHtmlBody(std::shared_ptr<BaseNode> bodyContent) {
    WriteIndent();
    WriteHtml("<body>");
    WriteNewline();
    
    if (bodyContent) {
        IncreaseIndent();
        bodyContent->Accept(*this);
        DecreaseIndent();
    }
    
    // 如果有JavaScript内容，生成script标签
    std::string jsContent = jsStream.str();
    if (!jsContent.empty()) {
        WriteIndent();
        WriteHtml("<script>");
        WriteNewline();
        WriteHtml(jsContent);
        WriteIndent();
        WriteHtml("</script>");
        WriteNewline();
    }
    
    WriteIndent();
    WriteHtml("</body>");
    WriteNewline();
}

void HtmlGenerator::GenerateElementStart(ElementNode& element) {
    if (options.prettyPrint && !isInlineContext) {
        WriteIndent();
    }
    
    WriteHtml("<" + element.GetTagName());
    
    // 生成属性
    GenerateAttributes(element);
    
    if (element.IsSelfClosing()) {
        WriteHtml(" />");
    } else {
        WriteHtml(">");
    }
}

void HtmlGenerator::GenerateElementEnd(ElementNode& element) {
    if (!element.IsSelfClosing()) {
        WriteHtml("</" + element.GetTagName() + ">");
    }
}

void HtmlGenerator::GenerateAttributes(ElementNode& element) {
    for (const auto& attr : element.GetAttributes()) {
        WriteHtml(" " + attr.first + "=\"" + EscapeAttribute(attr.second) + "\"");
    }
}

void HtmlGenerator::GenerateTextContent(const std::string& text) {
    WriteHtml(EscapeHtml(text));
}

void HtmlGenerator::GenerateComment(CommentNode& comment) {
    if (comment.IsGeneratorComment()) {
        // 生成器注释根据上下文决定格式
        if (options.prettyPrint) {
            WriteIndent();
        }
        WriteHtml("<!-- " + EscapeHtml(comment.GetContent()) + " -->");
        if (options.prettyPrint) {
            WriteNewline();
        }
    } else if (options.includeMetadata) {
        // 只有在包含元数据选项开启时才输出普通注释
        if (options.prettyPrint) {
            WriteIndent();
        }
        WriteHtml("<!-- " + EscapeHtml(comment.GetContent()) + " -->");
        if (options.prettyPrint) {
            WriteNewline();
        }
    }
}

void HtmlGenerator::ProcessStyleBlock(StyleBlockNode& styleBlock) {
    // 处理内联样式
    std::string inlineStyles = styleBlock.GenerateInlineStyles();
    if (!inlineStyles.empty()) {
        // 将内联样式添加到父元素（如果可能）
        // 这里需要从访问者模式获取上下文，简化处理
    }
    
    // 处理全局CSS
    std::string globalCss = styleBlock.GenerateGlobalCss();
    if (!globalCss.empty()) {
        WriteCss(globalCss);
        WriteCss("\n");
    }
    
    // 记录自动生成的类和ID
    for (const auto& className : styleBlock.GetAutoGeneratedClasses()) {
        autoGeneratedClasses.insert(className);
    }
    
    for (const auto& id : styleBlock.GetAutoGeneratedIds()) {
        autoGeneratedIds.insert(id);
    }
}

void HtmlGenerator::ProcessScriptBlock(ScriptBlockNode& scriptBlock) {
    std::string jsCode = scriptBlock.GenerateJavaScript();
    if (!jsCode.empty()) {
        // 处理CHTL JS语法
        jsCode = ProcessCHTLJSSyntax(jsCode);
        WriteJs(jsCode);
        WriteJs("\n");
    }
    
    // 记录自动生成的类和ID
    for (const auto& className : scriptBlock.GetAutoAddedClasses()) {
        autoGeneratedClasses.insert(className);
    }
    
    for (const auto& id : scriptBlock.GetAutoAddedIds()) {
        autoGeneratedIds.insert(id);
    }
}

std::string HtmlGenerator::ProcessCHTLJSSyntax(const std::string& script) {
    std::string processed = script;
    
    // 处理增强选择器 {{selector}} -> document.querySelector/querySelectorAll
    // 简化处理：直接字符串替换
    size_t pos = 0;
    while ((pos = processed.find("{{", pos)) != std::string::npos) {
        size_t endPos = processed.find("}}", pos + 2);
        if (endPos != std::string::npos) {
            std::string selector = processed.substr(pos + 2, endPos - pos - 2);
            std::string replacement;
            
            if (selector.find("[") != std::string::npos) {
                // 带索引的选择器
                replacement = "document.querySelectorAll('" + selector.substr(0, selector.find("[")) + "')";
            } else {
                replacement = "document.querySelector('" + selector + "')";
            }
            
            processed.replace(pos, endPos - pos + 2, replacement);
            pos += replacement.length();
        } else {
            break;
        }
    }
    
    // 处理 -> 操作符，转换为普通的 .
    pos = 0;
    while ((pos = processed.find("->", pos)) != std::string::npos) {
        processed.replace(pos, 2, ".");
        pos += 1;
    }
    
    return processed;
}

std::string HtmlGenerator::EscapeHtml(const std::string& text) {
    std::string escaped = text;
    
    // 替换HTML特殊字符
    std::regex htmlRegex("&");
    escaped = std::regex_replace(escaped, htmlRegex, "&amp;");
    
    htmlRegex = std::regex("<");
    escaped = std::regex_replace(escaped, htmlRegex, "&lt;");
    
    htmlRegex = std::regex(">");
    escaped = std::regex_replace(escaped, htmlRegex, "&gt;");
    
    htmlRegex = std::regex("\"");
    escaped = std::regex_replace(escaped, htmlRegex, "&quot;");
    
    return escaped;
}

std::string HtmlGenerator::EscapeAttribute(const std::string& value) {
    std::string escaped = value;
    
    // 替换属性值中的特殊字符
    std::regex quotRegex("\"");
    escaped = std::regex_replace(escaped, quotRegex, "&quot;");
    
    std::regex ampRegex("&");
    escaped = std::regex_replace(escaped, ampRegex, "&amp;");
    
    return escaped;
}

void HtmlGenerator::ApplyAutomaticIdentifiers(ElementNode& element) {
    // 这里可以添加自动化类名和ID的逻辑
    // 基于样式块中的自动生成信息
}

void HtmlGenerator::AddError(const std::string& message) {
    errors.push_back("HTML生成错误: " + message);
}

void HtmlGenerator::AddWarning(const std::string& message) {
    warnings.push_back("HTML生成警告: " + message);
}

void HtmlGenerator::ResetState() {
    htmlStream.str("");
    htmlStream.clear();
    cssStream.str("");
    cssStream.clear();
    jsStream.str("");
    jsStream.clear();
    
    indentLevel = 0;
    isInlineContext = false;
    autoGeneratedClasses.clear();
    autoGeneratedIds.clear();
    errors.clear();
    warnings.clear();
}

std::shared_ptr<ElementNode> HtmlGenerator::FindHtmlRoot(std::shared_ptr<BaseNode> rootNode) {
    if (!rootNode) return nullptr;
    
    // 检查根节点本身是否为HTML元素
    if (rootNode->GetNodeType() == NodeType::ELEMENT) {
        auto element = std::static_pointer_cast<ElementNode>(rootNode);
        if (element->GetTagName() == "html") {
            return element;
        }
    }
    
    // 在子节点中查找HTML元素
    for (const auto& child : rootNode->GetChildren()) {
        if (child->GetNodeType() == NodeType::ELEMENT) {
            auto element = std::static_pointer_cast<ElementNode>(child);
            if (element->GetTagName() == "html") {
                return element;
            }
        }
    }
    
    return nullptr;
}

std::shared_ptr<BaseNode> HtmlGenerator::ExtractBodyContent(std::shared_ptr<BaseNode> rootNode) {
    if (!rootNode) return nullptr;
    
    // 创建一个容器来保存body内容
    auto bodyContainer = std::make_shared<ElementNode>("div");
    
    // 将所有非HTML结构的子节点添加到body容器中
    for (const auto& child : rootNode->GetChildren()) {
        if (child->GetNodeType() == NodeType::ELEMENT) {
            auto element = std::static_pointer_cast<ElementNode>(child);
            if (element->GetTagName() != "html" && 
                element->GetTagName() != "head" && 
                element->GetTagName() != "body") {
                bodyContainer->AddChild(child);
            }
        } else {
            bodyContainer->AddChild(child);
        }
    }
    
    return bodyContainer;
}

HtmlGenerationResult HtmlGenerator::CreateResult() {
    HtmlGenerationResult result;
    result.htmlContent = htmlStream.str();
    result.cssContent = cssStream.str();
    result.jsContent = jsStream.str();
    result.errors = errors;
    result.warnings = warnings;
    result.success = errors.empty();
    return result;
}

// HtmlGeneratorFactory实现

std::unique_ptr<HtmlGenerator> HtmlGeneratorFactory::CreateStandardGenerator() {
    HtmlGenerationOptions options;
    options.prettyPrint = true;
    options.generateDoctype = true;
    options.includeMetadata = false;
    return std::make_unique<HtmlGenerator>(options);
}

std::unique_ptr<HtmlGenerator> HtmlGeneratorFactory::CreateMinifiedGenerator() {
    HtmlGenerationOptions options;
    options.prettyPrint = false;
    options.generateDoctype = true;
    options.includeMetadata = false;
    options.indentString = "";
    return std::make_unique<HtmlGenerator>(options);
}

std::unique_ptr<HtmlGenerator> HtmlGeneratorFactory::CreateDevelopmentGenerator() {
    HtmlGenerationOptions options;
    options.prettyPrint = true;
    options.generateDoctype = true;
    options.includeMetadata = true;
    return std::make_unique<HtmlGenerator>(options);
}

} // namespace CHTL
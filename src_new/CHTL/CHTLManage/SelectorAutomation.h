#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <memory>

namespace CHTL {
namespace Common {

// 选择器类型
enum class SelectorType {
    CLASS,          // .class
    ID,             // #id
    TAG,            // tag
    PSEUDO_CLASS,   // :hover, :focus等
    PSEUDO_ELEMENT, // ::before, ::after等
    REFERENCE,      // & 引用选择器
    GENERAL         // 一般选择器（如{{box}}）
};

// 上下文类型（决定自动化行为）
enum class AutomationContext {
    LOCAL_STYLE,    // 局部样式块
    LOCAL_SCRIPT,   // 局部脚本块
    GLOBAL_STYLE,   // 全局样式块（不支持自动化）
    GLOBAL_SCRIPT   // 全局脚本块（不支持自动化）
};

// 选择器信息
struct SelectorInfo {
    SelectorType type;
    std::string name;
    std::string full_selector;
    bool is_auto_generated;
    AutomationContext context;
    size_t priority;  // 优先级（用于多选择器排序）
    
    SelectorInfo() : type(SelectorType::GENERAL), is_auto_generated(false), 
                     context(AutomationContext::LOCAL_STYLE), priority(0) {}
    
    SelectorInfo(SelectorType t, const std::string& n, AutomationContext ctx)
        : type(t), name(n), full_selector(buildFullSelector(t, n)), 
          is_auto_generated(false), context(ctx), priority(0) {}
    
    static std::string buildFullSelector(SelectorType type, const std::string& name);
    bool isClassSelector() const { return type == SelectorType::CLASS; }
    bool isIdSelector() const { return type == SelectorType::ID; }
    bool isReference() const { return type == SelectorType::REFERENCE; }
};

// 自动化配置
struct AutomationConfig {
    // 配置开关（来自[Configuration]）
    bool disable_style_auto_add_class;
    bool disable_style_auto_add_id;
    bool disable_script_auto_add_class;
    bool disable_script_auto_add_id;
    
    AutomationConfig() : disable_style_auto_add_class(false), 
                        disable_style_auto_add_id(false),
                        disable_script_auto_add_class(true),  // 默认禁用
                        disable_script_auto_add_id(true) {}   // 默认禁用
};

// 选择器自动化管理器
class SelectorAutomation {
public:
    SelectorAutomation();
    ~SelectorAutomation();
    
    // 配置管理
    void setConfig(const AutomationConfig& config) { this->config = config; }
    AutomationConfig getConfig() const { return config; }
    
    // 选择器注册和管理
    void registerSelector(const std::string& element_path, const SelectorInfo& selector);
    void removeSelector(const std::string& element_path, const std::string& selector_name);
    std::vector<SelectorInfo> getSelectorsForElement(const std::string& element_path) const;
    
    // 自动化核心功能
    
    // 检查是否需要自动添加class
    bool shouldAutoAddClass(const std::string& element_path, AutomationContext context) const;
    
    // 检查是否需要自动添加id  
    bool shouldAutoAddId(const std::string& element_path, AutomationContext context) const;
    
    // 获取需要自动添加的class名称
    std::string getAutoClassName(const std::string& element_path, AutomationContext context) const;
    
    // 获取需要自动添加的id名称
    std::string getAutoIdName(const std::string& element_path, AutomationContext context) const;
    
    // 引用选择器解析
    
    // 解析&引用选择器，局部style优先class，局部script优先id
    std::string resolveReference(const std::string& element_path, AutomationContext context) const;
    
    // 获取引用选择器的类型（class或id）
    SelectorType getReferenceType(const std::string& element_path, AutomationContext context) const;
    
    // 特殊规则处理
    
    // 检查CHTL JS选择器自动化规则
    // {{box}}不会触发自动添加，只有{{.box}}和{{#box}}能够触发
    bool canTriggerAutomation(const std::string& selector, AutomationContext context) const;
    
    // 检查是否存在已有的class/id属性
    bool hasExistingClassAttribute(const std::string& element_path) const;
    bool hasExistingIdAttribute(const std::string& element_path) const;
    
    // 检查局部style是否已经触发了自动化
    bool hasStyleTriggeredClassAutomation(const std::string& element_path) const;
    bool hasStyleTriggeredIdAutomation(const std::string& element_path) const;
    
    // 多选择器处理
    
    // 获取第一个类选择器（用于自动添加）
    std::string getFirstClassSelector(const std::string& element_path, AutomationContext context) const;
    
    // 获取第一个ID选择器（用于自动添加）
    std::string getFirstIdSelector(const std::string& element_path, AutomationContext context) const;
    
    // 排序选择器（按优先级和声明顺序）
    std::vector<SelectorInfo> getSortedSelectors(const std::string& element_path, 
                                                  SelectorType type) const;
    
    // 验证和修正
    
    // 验证选择器名称的有效性
    bool isValidSelectorName(const std::string& name, SelectorType type) const;
    
    // 修正选择器名称（去除无效字符等）
    std::string correctSelectorName(const std::string& name, SelectorType type) const;
    
    // 生成唯一的选择器名称
    std::string generateUniqueSelector(SelectorType type, const std::string& prefix = "") const;
    
    // 状态查询
    
    // 获取元素的所有自动生成的选择器
    std::vector<std::string> getAutoGeneratedSelectors(const std::string& element_path) const;
    
    // 检查选择器是否已存在
    bool selectorExists(const std::string& element_path, const std::string& selector_name) const;
    
    // 获取元素当前的class和id
    std::string getCurrentClass(const std::string& element_path) const;
    std::string getCurrentId(const std::string& element_path) const;
    
    // 调试和诊断
    void dumpAutomationState(const std::string& element_path) const;
    std::unordered_map<std::string, std::vector<SelectorInfo>> getAllSelectors() const;
    
    // 清理
    void clearElement(const std::string& element_path);
    void clearAll();

private:
    AutomationConfig config;
    
    // 选择器存储：元素路径 -> 选择器列表
    std::unordered_map<std::string, std::vector<SelectorInfo>> element_selectors;
    
    // 自动化状态跟踪
    std::unordered_map<std::string, bool> style_class_automation_triggered;
    std::unordered_map<std::string, bool> style_id_automation_triggered;
    std::unordered_map<std::string, std::string> auto_generated_classes;
    std::unordered_map<std::string, std::string> auto_generated_ids;
    
    // 元素属性跟踪
    std::unordered_map<std::string, std::string> element_class_attrs;
    std::unordered_map<std::string, std::string> element_id_attrs;
    
    // 计数器（用于生成唯一名称）
    mutable size_t class_counter;
    mutable size_t id_counter;
    
    // 内部辅助方法
    
    // 解析选择器类型
    SelectorType parseSelectorType(const std::string& selector) const;
    
    // 提取选择器名称（去掉前缀符号）
    std::string extractSelectorName(const std::string& selector, SelectorType type) const;
    
    // 检查上下文是否支持自动化
    bool contextSupportsAutomation(AutomationContext context) const;
    
    // 根据上下文确定引用优先级
    SelectorType getReferencePriority(AutomationContext context) const;
    
    // 查找最适合的引用目标
    SelectorInfo findBestReferenceTarget(const std::string& element_path, 
                                        AutomationContext context) const;
    
    // 更新自动化状态
    void updateAutomationState(const std::string& element_path, SelectorType type, 
                              const std::string& name);
    
    // 检查配置禁用状态
    bool isAutomationDisabled(AutomationContext context, SelectorType type) const;
};

// 工具函数
class SelectorUtils {
public:
    // 解析CHTL JS选择器
    static SelectorType parseCHTLJSSelector(const std::string& selector);
    
    // 检查是否是有效的CSS选择器名称
    static bool isValidCSSName(const std::string& name);
    
    // 规范化选择器名称
    static std::string normalizeSelectorName(const std::string& name);
    
    // 生成CSS安全的名称
    static std::string generateCSSSafeName(const std::string& input);
    
    // 检查选择器冲突
    static bool hasConflict(const std::vector<SelectorInfo>& selectors);
    
    // 获取选择器优先级
    static size_t getSelectorPriority(const SelectorInfo& selector);
    
    // 比较选择器优先级
    static bool compareSelectorPriority(const SelectorInfo& a, const SelectorInfo& b);
};

} // namespace Common
} // namespace CHTL
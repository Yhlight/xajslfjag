#include "SelectorAutomation.h"
#include <algorithm>
#include <sstream>
#include <cctype>

namespace CHTL {

SelectorAutomation::SelectorAutomation() {
    // 使用默认的自动化规则
}

void SelectorAutomation::setAutomationRule(const AutomationRule& rule) {
    automationRule_ = rule;
}

std::vector<Selector> SelectorAutomation::parseSelectors(const std::string& selectorText, size_t line, size_t column) {
    std::vector<Selector> selectors;
    
    if (selectorText.empty()) {
        return selectors;
    }
    
    // 分割选择器
    auto selectorParts = splitSelectors(selectorText);
    
    for (const auto& part : selectorParts) {
        SelectorType type = detectSelectorType(part);
        Selector selector(type, part, selectorText, line, column);
        selectors.push_back(selector);
        
        // 更新统计
        statistics_.totalSelectorsProcessed++;
    }
    
    return selectors;
}

bool SelectorAutomation::validateSelector(const std::string& selectorText) {
    if (selectorText.empty()) {
        return false;
    }
    
    // 基本验证：检查是否包含有效的选择器字符
    for (char c : selectorText) {
        if (!std::isalnum(c) && c != '.' && c != '#' && c != ':' && c != '[' && c != ']' && 
            c != '(' && c != ')' && c != '=' && c != '~' && c != '|' && c != '^' && c != '$' && 
            c != '*' && c != '>' && c != '+' && c != '~' && c != ' ' && c != '\t') {
            return false;
        }
    }
    
    return true;
}

SelectorType SelectorAutomation::detectSelectorType(const std::string& selector) {
    if (selector.empty()) {
        return SelectorType::TAG;
    }
    
    if (selector[0] == '.') {
        return SelectorType::CLASS;
    } else if (selector[0] == '#') {
        return SelectorType::ID;
    } else if (selector[0] == ':') {
        if (selector.length() > 1 && selector[1] == ':') {
            return SelectorType::PSEUDO_ELEMENT;
        } else {
            return SelectorType::PSEUDO_CLASS;
        }
    } else if (selector == "*") {
        return SelectorType::UNIVERSAL;
    } else if (selector == ">" || selector == "+" || selector == "~" || selector == " ") {
        return SelectorType::COMBINATOR;
    } else {
        return SelectorType::TAG;
    }
}

void SelectorAutomation::processStyleBlock(SelectorContext& context) {
    if (!context.hasStyleBlock) {
        return;
    }
    
    // 处理样式块自动化
    if (shouldAutoAddClass(context, true)) {
        std::string className = getFirstClassSelector(context);
        if (!className.empty()) {
            context.classNames.push_back(className);
            statistics_.totalAutoGeneratedClasses++;
        }
    }
    
    if (shouldAutoAddId(context, true)) {
        std::string idName = getFirstIdSelector(context);
        if (!idName.empty()) {
            context.idNames.push_back(idName);
            statistics_.totalAutoGeneratedIds++;
        }
    }
    
    statistics_.totalStyleBlocksProcessed++;
}

void SelectorAutomation::processScriptBlock(SelectorContext& context) {
    if (!context.hasScriptBlock) {
        return;
    }
    
    // 处理脚本块自动化
    if (shouldAutoAddClass(context, false)) {
        std::string className = getFirstClassSelector(context);
        if (!className.empty()) {
            context.classNames.push_back(className);
            statistics_.totalAutoGeneratedClasses++;
        }
    }
    
    if (shouldAutoAddId(context, false)) {
        std::string idName = getFirstIdSelector(context);
        if (!idName.empty()) {
            context.idNames.push_back(idName);
            statistics_.totalAutoGeneratedIds++;
        }
    }
    
    statistics_.totalScriptBlocksProcessed++;
}

std::string SelectorAutomation::resolveReferenceSelector(const std::string& reference, const SelectorContext& context) {
    if (reference.empty()) {
        return "";
    }
    
    // 处理 & 引用
    if (reference == "&") {
        return resolveAmpersandReference(reference, context);
    }
    
    // 处理增强选择器引用
    if (reference.find("{{") != std::string::npos) {
        return resolveEnhancedSelectorReference(reference, context);
    }
    
    return reference;
}

bool SelectorAutomation::shouldAutoAddClass(const SelectorContext& context, bool isStyleBlock) const {
    if (isStyleBlock) {
        return !automationRule_.disableStyleAutoAddClass;
    } else {
        return !automationRule_.disableScriptAutoAddClass;
    }
}

bool SelectorAutomation::shouldAutoAddId(const SelectorContext& context, bool isStyleBlock) const {
    if (isStyleBlock) {
        return !automationRule_.disableStyleAutoAddId;
    } else {
        return !automationRule_.disableScriptAutoAddId;
    }
}

std::string SelectorAutomation::getFirstClassSelector(const SelectorContext& context) const {
    for (const auto& selector : context.selectors) {
        if (selector.type == SelectorType::CLASS) {
            return selector.value;
        }
    }
    return "";
}

std::string SelectorAutomation::getFirstIdSelector(const SelectorContext& context) const {
    for (const auto& selector : context.selectors) {
        if (selector.type == SelectorType::ID) {
            return selector.value;
        }
    }
    return "";
}

void SelectorAutomation::clearStatistics() {
    statistics_ = Statistics();
}

std::string SelectorAutomation::getDebugInfo() const {
    std::ostringstream oss;
    oss << "SelectorAutomation Debug Info:\n";
    oss << "Total selectors processed: " << statistics_.totalSelectorsProcessed << "\n";
    oss << "Total auto-generated classes: " << statistics_.totalAutoGeneratedClasses << "\n";
    oss << "Total auto-generated IDs: " << statistics_.totalAutoGeneratedIds << "\n";
    oss << "Total style blocks processed: " << statistics_.totalStyleBlocksProcessed << "\n";
    oss << "Total script blocks processed: " << statistics_.totalScriptBlocksProcessed << "\n";
    oss << "Automation rules:\n";
    oss << "  Disable style auto-add class: " << (automationRule_.disableStyleAutoAddClass ? "Yes" : "No") << "\n";
    oss << "  Disable style auto-add ID: " << (automationRule_.disableStyleAutoAddId ? "Yes" : "No") << "\n";
    oss << "  Disable script auto-add class: " << (automationRule_.disableScriptAutoAddClass ? "Yes" : "No") << "\n";
    oss << "  Disable script auto-add ID: " << (automationRule_.disableScriptAutoAddId ? "Yes" : "No") << "\n";
    
    return oss.str();
}

std::vector<std::string> SelectorAutomation::splitSelectors(const std::string& selectorText) {
    std::vector<std::string> selectors;
    std::istringstream iss(selectorText);
    std::string selector;
    
    while (std::getline(iss, selector, ',')) {
        // 去除首尾空格
        selector.erase(0, selector.find_first_not_of(" \t"));
        selector.erase(selector.find_last_not_of(" \t") + 1);
        
        if (!selector.empty()) {
            selectors.push_back(selector);
        }
    }
    
    return selectors;
}

bool SelectorAutomation::isClassSelector(const std::string& selector) {
    return !selector.empty() && selector[0] == '.';
}

bool SelectorAutomation::isIdSelector(const std::string& selector) {
    return !selector.empty() && selector[0] == '#';
}

bool SelectorAutomation::isTagSelector(const std::string& selector) {
    if (selector.empty()) {
        return false;
    }
    
    char first = selector[0];
    return std::isalpha(first) || first == '_';
}

bool SelectorAutomation::isPseudoClassSelector(const std::string& selector) {
    return selector.length() > 1 && selector[0] == ':' && selector[1] != ':';
}

bool SelectorAutomation::isPseudoElementSelector(const std::string& selector) {
    return selector.length() > 2 && selector[0] == ':' && selector[1] == ':';
}

bool SelectorAutomation::isCombinatorSelector(const std::string& selector) {
    return selector == ">" || selector == "+" || selector == "~" || selector == " ";
}

bool SelectorAutomation::isUniversalSelector(const std::string& selector) {
    return selector == "*";
}

std::string SelectorAutomation::extractSelectorValue(const std::string& selector) {
    if (selector.empty()) {
        return "";
    }
    
    if (selector[0] == '.' || selector[0] == '#') {
        return selector.substr(1);
    }
    
    return selector;
}

std::string SelectorAutomation::normalizeSelector(const std::string& selector) {
    std::string normalized = selector;
    
    // 去除首尾空格
    normalized.erase(0, normalized.find_first_not_of(" \t"));
    normalized.erase(normalized.find_last_not_of(" \t") + 1);
    
    // 转换为小写（对于标签选择器）
    if (isTagSelector(normalized)) {
        std::transform(normalized.begin(), normalized.end(), normalized.begin(), ::tolower);
    }
    
    return normalized;
}

std::string SelectorAutomation::resolveAmpersandReference(const std::string& reference, const SelectorContext& context) {
    if (reference != "&") {
        return reference;
    }
    
    // 构建当前元素的选择器
    std::ostringstream oss;
    
    if (!context.elementName.empty()) {
        oss << context.elementName;
    }
    
    for (const auto& className : context.classNames) {
        oss << "." << className;
    }
    
    for (const auto& idName : context.idNames) {
        oss << "#" << idName;
    }
    
    return oss.str();
}

std::string SelectorAutomation::resolveEnhancedSelectorReference(const std::string& reference, const SelectorContext& context) {
    // 处理 {{.class}} 和 {{#id}} 引用
    if (reference.find("{{.") != std::string::npos) {
        // 替换 {{.class}} 为实际的类选择器
        std::string result = reference;
        size_t pos = result.find("{{.");
        while (pos != std::string::npos) {
            size_t endPos = result.find("}}", pos);
            if (endPos != std::string::npos) {
                std::string placeholder = result.substr(pos, endPos - pos + 2);
                std::string className = result.substr(pos + 3, endPos - pos - 3);
                
                // 查找对应的类选择器
                std::string replacement = "";
                for (const auto& selector : context.selectors) {
                    if (selector.type == SelectorType::CLASS && selector.value == className) {
                        replacement = "." + className;
                        break;
                    }
                }
                
                if (!replacement.empty()) {
                    result.replace(pos, endPos - pos + 2, replacement);
                }
            }
            pos = result.find("{{.", pos + 1);
        }
        return result;
    }
    
    if (reference.find("{{#") != std::string::npos) {
        // 替换 {{#id}} 为实际的ID选择器
        std::string result = reference;
        size_t pos = result.find("{{#");
        while (pos != std::string::npos) {
            size_t endPos = result.find("}}", pos);
            if (endPos != std::string::npos) {
                std::string placeholder = result.substr(pos, endPos - pos + 2);
                std::string idName = result.substr(pos + 3, endPos - pos - 3);
                
                // 查找对应的ID选择器
                std::string replacement = "";
                for (const auto& selector : context.selectors) {
                    if (selector.type == SelectorType::ID && selector.value == idName) {
                        replacement = "#" + idName;
                        break;
                    }
                }
                
                if (!replacement.empty()) {
                    result.replace(pos, endPos - pos + 2, replacement);
                }
            }
            pos = result.find("{{#", pos + 1);
        }
        return result;
    }
    
    return reference;
}

void SelectorAutomation::updateStatistics(const std::string& type, size_t value) {
    if (type == "selector") {
        statistics_.totalSelectorsProcessed += value;
    } else if (type == "class") {
        statistics_.totalAutoGeneratedClasses += value;
    } else if (type == "id") {
        statistics_.totalAutoGeneratedIds += value;
    } else if (type == "style") {
        statistics_.totalStyleBlocksProcessed += value;
    } else if (type == "script") {
        statistics_.totalScriptBlocksProcessed += value;
    }
}

} // namespace CHTL
#pragma once

#include <string>
#include <vector>
#include <memory>
#include <unordered_map>

namespace CHTL {

// 选择器类型
enum class SelectorType {
    CLASS,          // .class
    ID,             // #id
    TAG,            // tag
    PSEUDO_CLASS,   // :pseudo-class
    PSEUDO_ELEMENT, // ::pseudo-element
    COMBINATOR,     // >, +, ~, space
    UNIVERSAL       // *
};

// 选择器信息
struct Selector {
    SelectorType type;
    std::string value;
    std::string fullSelector;
    size_t line;
    size_t column;
    bool isAutoGenerated;
    
    Selector(SelectorType type, const std::string& value, const std::string& fullSelector = "",
             size_t line = 0, size_t column = 0, bool isAutoGenerated = false)
        : type(type), value(value), fullSelector(fullSelector), line(line), column(column), 
          isAutoGenerated(isAutoGenerated) {}
};

// 选择器上下文
struct SelectorContext {
    std::string elementName;
    std::vector<std::string> classNames;
    std::vector<std::string> idNames;
    std::vector<Selector> selectors;
    bool hasStyleBlock;
    bool hasScriptBlock;
    std::string sourceFile;
    size_t line;
    
    SelectorContext() : hasStyleBlock(false), hasScriptBlock(false), line(0) {}
};

// 自动化规则
struct AutomationRule {
    bool disableStyleAutoAddClass;
    bool disableStyleAutoAddId;
    bool disableScriptAutoAddClass;
    bool disableScriptAutoAddId;
    
    AutomationRule() : disableStyleAutoAddClass(false), disableStyleAutoAddId(false),
                       disableScriptAutoAddClass(true), disableScriptAutoAddId(true) {}
};

// 选择器自动化管理器
class SelectorAutomation {
public:
    SelectorAutomation();
    ~SelectorAutomation() = default;
    
    // 设置自动化规则
    void setAutomationRule(const AutomationRule& rule);
    const AutomationRule& getAutomationRule() const { return automationRule_; }
    
    // 解析选择器
    std::vector<Selector> parseSelectors(const std::string& selectorText, size_t line = 0, size_t column = 0);
    
    // 验证选择器
    bool validateSelector(const std::string& selectorText);
    
    // 检测选择器类型
    SelectorType detectSelectorType(const std::string& selector);
    
    // 处理样式块
    void processStyleBlock(SelectorContext& context);
    
    // 处理脚本块
    void processScriptBlock(SelectorContext& context);
    
    // 解析引用选择器
    std::string resolveReferenceSelector(const std::string& reference, const SelectorContext& context);
    
    // 自动添加类/ID
    bool shouldAutoAddClass(const SelectorContext& context, bool isStyleBlock) const;
    bool shouldAutoAddId(const SelectorContext& context, bool isStyleBlock) const;
    
    // 获取第一个类选择器
    std::string getFirstClassSelector(const SelectorContext& context) const;
    
    // 获取第一个ID选择器
    std::string getFirstIdSelector(const SelectorContext& context) const;
    
    // 统计信息
    struct Statistics {
        size_t totalSelectorsProcessed;
        size_t totalAutoGeneratedClasses;
        size_t totalAutoGeneratedIds;
        size_t totalStyleBlocksProcessed;
        size_t totalScriptBlocksProcessed;
        
        Statistics() : totalSelectorsProcessed(0), totalAutoGeneratedClasses(0), 
                       totalAutoGeneratedIds(0), totalStyleBlocksProcessed(0), 
                       totalScriptBlocksProcessed(0) {}
    };
    
    const Statistics& getStatistics() const { return statistics_; }
    void clearStatistics();
    
    // 调试信息
    std::string getDebugInfo() const;
    
private:
    AutomationRule automationRule_;
    Statistics statistics_;
    
    // 辅助函数
    std::vector<std::string> splitSelectors(const std::string& selectorText);
    bool isClassSelector(const std::string& selector);
    bool isIdSelector(const std::string& selector);
    bool isTagSelector(const std::string& selector);
    bool isPseudoClassSelector(const std::string& selector);
    bool isPseudoElementSelector(const std::string& selector);
    bool isCombinatorSelector(const std::string& selector);
    bool isUniversalSelector(const std::string& selector);
    
    // 选择器解析
    std::string extractSelectorValue(const std::string& selector);
    std::string normalizeSelector(const std::string& selector);
    
    // 引用解析
    std::string resolveAmpersandReference(const std::string& reference, const SelectorContext& context);
    std::string resolveEnhancedSelectorReference(const std::string& reference, const SelectorContext& context);
    
    // 统计更新
    void updateStatistics(const std::string& type, size_t value = 1);
};

} // namespace CHTL